//START OF FILE: src/grail/animation/animationcommandobject.java
package grail.animation;

import grail.avatar.Avatar;
import grail.helpers.ClearanceManager;
import util.annotations.Tags;

@Tags({"AnimatingCommand"})
public class AnimationCommandObject implements Runnable {
	private Avatar currentAvatar;
	private Animator animation;
	private String command;
	private String walkCommand = "walk";
	private String clapCommand = "clap";
	private int distanceToWalkorTimeToClap, sleepTime;
	private ClearanceManager manage;
	
	public AnimationCommandObject(Animator toAnimate, String command, Avatar cAvatar) {
		this.currentAvatar = cAvatar;
		this.animation = toAnimate;
		this.command = command;
	}
	
	public AnimationCommandObject(Animator toAnimate, String command, Avatar cAvatar, int distanceToWalkorTimeToClap) {
		this.currentAvatar = cAvatar;
		this.animation = toAnimate;
		this.command = command;
		this.distanceToWalkorTimeToClap = distanceToWalkorTimeToClap;
	}
	
	public AnimationCommandObject(Animator toAnimate, String command, Avatar cAvatar, int distanceToWalk, int sleepTime) {
		this.currentAvatar = cAvatar;
		this.animation = toAnimate;
		this.command = command;
		this.distanceToWalkorTimeToClap = distanceToWalk;
		this.sleepTime = sleepTime;
	}
	
	public AnimationCommandObject(Animator toAnimate, ClearanceManager manage, String command, Avatar cAvatar) {
		this.currentAvatar = cAvatar;
		this.animation = toAnimate;
		this.command = command;
		this.manage = manage;
	}
	
	public AnimationCommandObject(Animator toAnimate, ClearanceManager manage,  String command, Avatar cAvatar, int distanceToWalkorTimeToClap) {
		this.currentAvatar = cAvatar;
		this.animation = toAnimate;
		this.command = command;
		this.distanceToWalkorTimeToClap = distanceToWalkorTimeToClap;
		this.manage = manage;
	}
	
	public AnimationCommandObject(Animator toAnimate, ClearanceManager manage, String command, Avatar cAvatar, int distanceToWalk, int sleepTime) {
		this.currentAvatar = cAvatar;
		this.animation = toAnimate;
		this.command = command;
		this.distanceToWalkorTimeToClap = distanceToWalk;
		this.sleepTime = sleepTime;
		this.manage = manage;
	}
		
	public void run() {
		if (this.manage == null) {
			runWithoutClearance();
		} else {
			this.manage.waitForProceed();
			runWithoutClearance();
		}
	}
	
	private void runWithoutClearance() {
		if (walkCommand.equals(this.command) && this.distanceToWalkorTimeToClap == 0 && this.sleepTime == 0) {
			this.animation.walkAvatar(this.currentAvatar); /*- missingMethodCall: (AnimationCommandObject.java:1) has not made expected call @Animator!@AnimateAvatar:@Avatar-
			 >void    This is that call.*/
		} else if (walkCommand.equals(this.command) && this.sleepTime == 0) {
			this.animation.walkAvatar(this.currentAvatar, this.distanceToWalkorTimeToClap);
		} else if (walkCommand.equals(this.command)) {
			this.animation.walkAvatar(this.currentAvatar, this.distanceToWalkorTimeToClap, this.sleepTime);
		} else if (clapCommand.equals(this.command)) {
			this.animation.clapAvatar(this.currentAvatar, this.distanceToWalkorTimeToClap);
		}
	}
	

}
//END OF FILE
//START OF FILE: src/grail/animation/animator.java
package grail.animation;

import grail.avatar.Avatar;
import util.annotations.Tags;

@Tags({"Animator"})
public interface Animator {
	@Tags({"animateAvatar"})
	public void walkAvatar(Avatar toAnimate);	
	public void walkAvatar(Avatar toAnimate, int distanceToWalk);
	public void walkAvatar(Avatar toAnimate, int distanceToWalk, int sleepTime);
	public void clapAvatar(Avatar toAnimate, int timeToClap);

}
//END OF FILE
//START OF FILE: src/grail/animation/basicavataranimator.java
package grail.animation;

import grail.avatar.Avatar;
import util.annotations.Tags;
import util.misc.ThreadSupport;

@Tags({"Animator"})
public class BasicAvatarAnimator implements Animator {

	
	@Tags({"animateAvatar"})
	public synchronized void walkAvatar(Avatar toAnimate) {
		final int distanceToMarch = 100;
		final int moveIncrementX = 10;
		final int moveIncrementY = 0;
		final int rotationAmount = 8;
		final int sleepBetweenTimeMS = 200;
		int distanceMarched = 0;
		int position = 0;
		while (distanceMarched < distanceToMarch) {
			if (position == 0) {
				toAnimate.move(moveIncrementX, moveIncrementY);
				toAnimate.getLegs().rotate(-rotationAmount);
				distanceMarched = distanceMarched + moveIncrementX;
				ThreadSupport.sleep(sleepBetweenTimeMS);
				position = 1;
			} else {
				toAnimate.move(moveIncrementX, moveIncrementY);
				toAnimate.getLegs().rotate(rotationAmount);
				distanceMarched = distanceMarched + moveIncrementX;
				ThreadSupport.sleep(sleepBetweenTimeMS);
				position = 0;
			}
		}
		
	}
	
	public synchronized void walkAvatar(Avatar toAnimate, int distanceToWalk) {
		int distanceToMarch = distanceToWalk;
		final int moveIncrementX = 10;
		final int moveIncrementY = 0;
		final int rotationAmount = 8;
		final int sleepBetweenTimeMS = 200;
		int distanceMarched = 0;
		int position = 0;
		while (distanceMarched < distanceToMarch) {
			if (position == 0) {
				toAnimate.move(moveIncrementX, moveIncrementY);
				toAnimate.getLegs().rotate(-rotationAmount);
				distanceMarched = distanceMarched + moveIncrementX;
				ThreadSupport.sleep(sleepBetweenTimeMS);
				position = 1;
			} else {
				toAnimate.move(moveIncrementX, moveIncrementY);
				toAnimate.getLegs().rotate(rotationAmount);
				distanceMarched = distanceMarched + moveIncrementX;
				ThreadSupport.sleep(sleepBetweenTimeMS);
				position = 0;
			}
		}
	}
	
	public synchronized void walkAvatar(Avatar toAnimate, int distanceToWalk, int sleepTime) {
		int distanceToMarch = distanceToWalk;
		final int moveIncrementX = 10;
		final int moveIncrementY = 0;
		final int rotationAmount = 8;
		int sleepBetweenTimeMS = sleepTime;
		int distanceMarched = 0;
		int position = 0;
		while (distanceMarched < distanceToMarch) {
			if (position == 0) {
				toAnimate.move(moveIncrementX, moveIncrementY);
				toAnimate.getLegs().rotate(-rotationAmount);
				distanceMarched = distanceMarched + moveIncrementX;
				ThreadSupport.sleep(sleepBetweenTimeMS);
				position = 1;
			} else {
				toAnimate.move(moveIncrementX, moveIncrementY);
				toAnimate.getLegs().rotate(rotationAmount);
				distanceMarched = distanceMarched + moveIncrementX;
				ThreadSupport.sleep(sleepBetweenTimeMS);
				position = 0;
			}
		}
		
	}

	public synchronized void clapAvatar(Avatar toAnimate, int secondsToClap) {
		final int clapMS = 200;
		final int fullClapMS = 400;
		final int msInASecond = 1000;
		final int clapTimeInMS = secondsToClap * msInASecond;
		final int clapRotate = 4;
		final double originalArmLeft = toAnimate.getArms().getLeftLine().getAngle();
		final double originalArmRight = toAnimate.getArms().getRightLine().getAngle();
		toAnimate.getArms().getLeftLine().setAngle(Math.PI);
		toAnimate.getArms().getRightLine().setAngle(Math.PI);
		
		int msClapped = 0;
		while (msClapped < clapTimeInMS) {
			toAnimate.getArms().getRightLine().rotate(clapRotate);
			ThreadSupport.sleep(clapMS);
			toAnimate.getArms().getRightLine().rotate(-clapRotate);
			ThreadSupport.sleep(clapMS);
			msClapped = msClapped + fullClapMS;
		}
		
		toAnimate.getArms().getRightLine().setAngle(originalArmRight);
		toAnimate.getArms().getLeftLine().setAngle(originalArmLeft);
	}


}
//END OF FILE
//START OF FILE: src/grail/animation/basiclockstepanimator.java
package grail.animation;

import grail.avatar.Avatar;
import grail.helpers.ClearanceManager;
import util.misc.ThreadSupport;

public class BasicLockstepAnimator implements LockstepAnimator {
	private ClearanceManager manager;
		
	public BasicLockstepAnimator(ClearanceManager manager) {
		this.manager = manager;
	}

	
	public synchronized void clapAvatar(Avatar toAnimate, int timesToClap) {
		final int armRotation = 7;
		final int sleepTime = 1000;
		int index = 0;
		
		while (index < timesToClap) {
			toAnimate.getArms().getLeftLine().rotate(armRotation);
			toAnimate.getArms().getRightLine().rotate(-armRotation);
			ThreadSupport.sleep(sleepTime);
			this.manager.proceedAll();
			toAnimate.getArms().getLeftLine().rotate(-armRotation);
			toAnimate.getArms().getRightLine().rotate(armRotation);
			ThreadSupport.sleep(sleepTime);
			this.manager.proceedAll();
			index++;
		}
	}

	public void marchAvatar(Avatar toAnimate, int distanceToMarch) {
		final int moveIncrementX = 10;
		final int moveIncrementY = 0;
		final int rotationAmount = 8;
		int distanceMarched = 0;
		int position = 0;
		while (distanceMarched < distanceToMarch) {
			if (position == 0) {
				this.manager.waitForProceed();
				toAnimate.move(moveIncrementX, moveIncrementY);
				toAnimate.getLegs().rotate(-rotationAmount);
				distanceMarched = distanceMarched + moveIncrementX;
				position = 1;
			} else {
				this.manager.waitForProceed();
				toAnimate.move(moveIncrementX, moveIncrementY);
				toAnimate.getLegs().rotate(rotationAmount);
				distanceMarched = distanceMarched + moveIncrementX;
				position = 0;
			}
		}
		
	}

}
//END OF FILE
//START OF FILE: src/grail/animation/lockstepanimator.java
package grail.animation;

import grail.avatar.Avatar;

public interface LockstepAnimator {
	public void marchAvatar(Avatar toAnimate, int timeToClap);
	public void clapAvatar(Avatar toAnimate, int timeToClap);
}
//END OF FILE
//START OF FILE: src/grail/animation/lockstepcommandobject.java
package grail.animation;

import grail.avatar.Avatar;

public class LockstepCommandObject implements Runnable {
	private LockstepAnimator animator;
	private String command;
	private int distanceToWalkorClap;
	private Avatar avatar;
	
	public LockstepCommandObject(LockstepAnimator animator,String command, Avatar toAnimate, int distanceToWalkOrClap ) {
		this.animator = animator;
		this.command = command;
		this.distanceToWalkorClap = distanceToWalkOrClap;
		this.avatar = toAnimate;
	}

	public void run() {
		if ("march".equals(this.command)) {
			this.animator.marchAvatar(this.avatar, this.distanceToWalkorClap);
		} else if ("clap".equals(this.command)) {
			this.animator.clapAvatar(this.avatar, this.distanceToWalkorClap);
		}
		
		
	}

}
//END OF FILE
//START OF FILE: src/grail/avatar/avatar.java
package grail.avatar;

import java.awt.Color;
import grail.draw.interfaces.AngleShape;
import grail.draw.interfaces.ImageShape;
import grail.draw.interfaces.RotatingShape;
import grail.draw.interfaces.StringShape;
import util.annotations.Tags;

@Tags({"Avatar"})
public interface Avatar {
	public String getBasicText();
	public void setBasicText(String setVal);
	public ImageShape getHead();
	public AngleShape getArms();
	public AngleShape getLegs();
	public RotatingShape getBody();
	public void move(int x, int y);
	public void scale(double scaleValue);
	public void setText(StringShape text);
	public StringShape getText();
	public void setLocation(int x, int y);
	public void setBodyColor(Color newBodyColor);
	public void setTextColor(Color newTextColor);
	public Color getBodyColor();
	public Color getTextColor();
	public int getHeight();
	public int getWidth();
	public int getX();
	public void setX(int newVal);
	public int getY();
	public void setY(int newVal);
	public void rebuild ();

}
//END OF FILE
//START OF FILE: src/grail/avatar/basicavatar.java
package grail.avatar;

import java.awt.Color;
import java.beans.PropertyChangeListener;

import grail.draw.interfaces.AngleShape;
import grail.draw.interfaces.ImageShape;
import grail.draw.interfaces.RotatingShape;
import grail.draw.interfaces.StringShape;
import grail.draw.objects.BasicAngleShape;
import grail.draw.objects.BasicImageShape;
import grail.draw.objects.BasicStringShape;
import grail.draw.objects.LineRotatingShape;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Avatar"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Head", "Arms", "Legs", "Body", "X", "Y", "Height","Width","Text", "BasicText", "BodyColor", "TextColor"})
@EditablePropertyNames({"X", "Y", "BasicText", "Text","BodyColor", "TextColor"})
public class BasicAvatar implements Avatar{
	private AngleShape arms, legs;
	private RotatingShape body;
	private ImageShape head;
	private StringShape text;
	private String basicText;
	private Color bodyColor, textColor;
	private int scaleFactor;
	private int x,y;
	
	
	public BasicAvatar(ImageShape head, int xPosStart, int yPosStart) {
		super();
		final int startingScaleFactor = 100;
		this.scaleFactor = startingScaleFactor;
		this.x = xPosStart;
		this.y = yPosStart;
		this.head = head;
		this.text = new BasicStringShape("Default", 0, 0);
		this.basicText = this.text.getText();
		this.body = new LineRotatingShape();
		this.arms = new BasicAngleShape(0, 0);
		this.legs = new BasicAngleShape(0, 0);		
		
		
		connectAvatar(xPosStart, yPosStart);
		final int defaultArmPosition = 8;
		this.arms.rotate(defaultArmPosition);
		this.legs.rotate(-defaultArmPosition);
		setBodyColor(Color.BLACK);
		setTextColor(Color.BLACK);

	}
	
	public BasicAvatar(String headImageString) {
		this(new BasicImageShape(headImageString));
		
	}
	
	public BasicAvatar(ImageShape head) {
		this (head, 0, 0);
	}

	
	public String getBasicText() {
		return this.basicText;
	}

	
	public void setBasicText(String setVal) {
		this.basicText = setVal;
		this.text.setText(setVal);
		
	}

	
	public ImageShape getHead() {
		return head;
	}

	
	public AngleShape getArms() {
		return arms;
	}

	
	public AngleShape getLegs() {
		return legs;
	}

	
	public RotatingShape getBody() {
		return body;
	}

	@Tags({"move"})
	public void move(int x, int y) {
		this.x = this.x + x;
		this.y = this.y + y;
		setLocation(this.x, this.y);
		
	}

	
	public void setX(int xPos) {
		this.x = xPos;
		setLocation(xPos, this.y);
		
		
	}

	
	public void setY(int yPos) {
		this.y = yPos;
		setLocation(this.x, yPos);
		
	}


	@Tags({"scale"})
	public void scale(double scaleValue) {
		this.scaleFactor = (int) (this.scaleFactor * scaleValue);
		connectAvatar(this.x,this.y);
	}

	
	public void setText(StringShape basicText) {
		this.text = basicText;
	}

	
	public StringShape getText() {
		return this.text;
	}
	
	public void setLocation(int x, int y) {
		connectAvatar(x,y);
		
	}
	
	private void connectAvatar(int xPos, int yPos) {
		int singleScaleFactor = this.scaleFactor;
		this.x = xPos;
		this.y = yPos;
		int headWidth = head.getWidth();
		int headHeight = head.getHeight();
		int xBodyPosition = headWidth/2 + xPos;
		int yBodyPosition = headHeight + yPos;
		
		this.head.setX(xPos);
		this.head.setY(yPos);
		
		this.body.setX(xBodyPosition);
		this.body.setY(yBodyPosition);
		this.body.setRadius(singleScaleFactor);
		this.body.setAngle(Math.PI/2);
		
		final double armScaleFactor = .40;
		final double armLengthFactor = .5;
		int armLocation = (int) (headHeight + yPos + singleScaleFactor * (armScaleFactor));
		this.arms.setX(xBodyPosition);
		this.arms.setY(armLocation);
		this.arms.getRightLine().setRadius(singleScaleFactor * armLengthFactor);
		this.arms.getLeftLine().setRadius(singleScaleFactor * armLengthFactor);
		
		final double legScaleFactor = .5;
		int bodyLocation = headHeight + yPos + singleScaleFactor;
		this.legs.setX(xBodyPosition);
		this.legs.setY(bodyLocation);
		this.legs.getRightLine().setRadius(singleScaleFactor * legScaleFactor);
		this.legs.getLeftLine().setRadius(singleScaleFactor * legScaleFactor);

		final int speachDistanceFromMouth = 10;
		this.text.setX(headWidth + xPos + speachDistanceFromMouth);
		this.text.setY(headHeight + yPos);
		
	}
	
	public void rebuild() {
		final int defaultScaleFactor = 100;
		final double startingRadius = 50;
		final double leftStartingAngle = Math.PI;
		final double rightStartingAngle = 0;
		this.scaleFactor = defaultScaleFactor;
		int singleScaleFactor = this.scaleFactor;
		int xPos = this.x;
		int yPos = this.y;
		
		this.getArms().getLeftLine().setRadius(startingRadius);
		this.getArms().getLeftLine().setAngle(leftStartingAngle);
		this.getArms().getRightLine().setRadius(startingRadius);
		this.getArms().getRightLine().setAngle(rightStartingAngle);
		
		this.getLegs().getLeftLine().setRadius(startingRadius);
		this.getLegs().getLeftLine().setAngle(leftStartingAngle);
		this.getLegs().getRightLine().setRadius(startingRadius);
		this.getLegs().getRightLine().setAngle(rightStartingAngle);
		
		int headWidth = head.getWidth();
		int headHeight = head.getHeight();
		int xBodyPosition = headWidth/2 + xPos;
		int yBodyPosition = headHeight + yPos;
		
		this.head.setX(xPos);
		this.head.setY(yPos);
		
		this.body.setX(xBodyPosition);
		this.body.setY(yBodyPosition);
		this.body.setRadius(singleScaleFactor);
		this.body.setAngle(Math.PI/2);
		
		final double armScaleFactor = .40;
		final double armLengthFactor = .5;
		int armLocation = (int) (headHeight + yPos + singleScaleFactor * (armScaleFactor));
		this.arms.setX(xBodyPosition);
		this.arms.setY(armLocation);
		this.arms.getRightLine().setRadius(singleScaleFactor * armLengthFactor);
		this.arms.getLeftLine().setRadius(singleScaleFactor * armLengthFactor);
		
		final double legScaleFactor = .5;
		int bodyLocation = headHeight + yPos + singleScaleFactor;
		this.legs.setX(xBodyPosition);
		this.legs.setY(bodyLocation);
		this.legs.getRightLine().setRadius(singleScaleFactor * legScaleFactor);
		this.legs.getLeftLine().setRadius(singleScaleFactor * legScaleFactor);

		final int speachDistanceFromMouth = 10;
		this.text.setX(headWidth + xPos + speachDistanceFromMouth);
		this.text.setY(headHeight + yPos);
		
		final int defaultArmPosition = 8;
		this.arms.rotate(defaultArmPosition);
		this.legs.rotate(-defaultArmPosition);
	}
	
	
	public void setBodyColor(Color newBodyColor) {
		this.bodyColor = newBodyColor;
		this.body.setColor(newBodyColor);
		this.arms.setColor(newBodyColor);
		this.legs.setColor(newBodyColor);
		
	}

	
	public void setTextColor(Color newbasicTextColor) {
		this.textColor = newbasicTextColor;
		this.text.setTextColor(newbasicTextColor);
		
	}

	
	public Color getBodyColor() {
		return bodyColor;
	}

	
	public Color getTextColor() {
		return textColor;
	}

	
	public int getHeight() {
		return Math.abs(this.body.getHeight())+ Math.abs(this.head.getHeight()) + Math.abs(this.legs.getRightLine().getHeight());

	}

	
	public int getWidth() {
		return Math.abs(this.legs.getRightLine().getWidth())* 2;
	}
	

	
	public int getX() {
		return this.x;
	}

	
	public int getY() {
		return this.y;
	}
	
	public static void addBodyListener(Avatar avatar, PropertyChangeListener listener) {
		avatar.getArms().addPropertyChangeListener(listener);
		BasicAngleShape.addListenersToSubshapes(avatar.getArms(), listener);
		avatar.getLegs().addPropertyChangeListener(listener);
		BasicAngleShape.addListenersToSubshapes(avatar.getLegs(), listener);
		avatar.getHead().addPropertyChangeListener(listener);
		avatar.getBody().addPropertyChangeListener(listener);
		avatar.getText().addPropertyChangeListener(listener);
	}




}
//END OF FILE
//START OF FILE: src/grail/command/approachcommandtoken.java
package grail.command;
import grail.interfaces.CommandToken;
import grail.tokens.WordStoreToken;
import util.annotations.Tags;

@Tags({"approach"})
public class ApproachCommandToken extends WordStoreToken implements CommandToken {

	public ApproachCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/command/callcommandtoken.java
package grail.command;
import grail.interfaces.CommandToken;
import grail.tokens.WordStoreToken;
import util.annotations.Tags;

@Tags({"call"})
public class CallCommandToken extends WordStoreToken implements CommandToken  {

	public CallCommandToken(String input) {
		super(input);
		
	}

}
//END OF FILE
//START OF FILE: src/grail/command/definecommandtoken.java
package grail.command;
import grail.interfaces.CommandToken;
import grail.tokens.WordStoreToken;
import util.annotations.Tags;

@Tags({"define"})
public class DefineCommandToken extends WordStoreToken implements CommandToken  {

	public DefineCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/command/failcommandtoken.java
package grail.command;

import grail.interfaces.CommandToken;
import grail.tokens.WordStoreToken;
import util.annotations.Tags;

@Tags({"fail"})
public class FailCommandToken extends WordStoreToken implements CommandToken {

	public FailCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/command/movecommandtoken.java
package grail.command;

import grail.interfaces.CommandToken;
import grail.tokens.WordStoreToken;
import util.annotations.Tags;

@Tags({"move"})

public class MoveCommandToken extends WordStoreToken implements CommandToken {

	public MoveCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/command/passcommandtoken.java
package grail.command;

import grail.interfaces.CommandToken;
import grail.tokens.WordStoreToken;
import util.annotations.Tags;

@Tags({"pass"})
public class PassCommandToken extends WordStoreToken implements CommandToken {

	public PassCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/command/printstoredcommandtoken.java
package grail.command;

import grail.interfaces.CommandToken;
import grail.tokens.WordStoreToken;
import util.annotations.Tags;

@Tags({"print"})
public class PrintStoredCommandToken extends WordStoreToken implements CommandToken {

	public PrintStoredCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/command/proceedallcommandtoken.java
package grail.command;
import grail.interfaces.CommandToken;
import grail.tokens.WordStoreToken;
import util.annotations.Tags;

@Tags({"proceedAll"})
public class ProceedAllCommandToken extends WordStoreToken implements CommandToken  {

	public ProceedAllCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/command/redocommandtoken.java
package grail.command;
import grail.interfaces.CommandToken;
import grail.tokens.WordStoreToken;
import util.annotations.Tags;

@Tags({"redo"})
public class RedoCommandToken extends WordStoreToken implements CommandToken {

	public RedoCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/command/repeatcommandtoken.java
package grail.command;

import grail.interfaces.CommandToken;
import grail.tokens.WordStoreToken;
import util.annotations.Tags;

@Tags({"repeat"})
public class RepeatCommandToken extends WordStoreToken implements CommandToken  {

	public RepeatCommandToken(String input) {
		super(input);
		// TODO Auto-generated constructor stub
	}

}
//END OF FILE
//START OF FILE: src/grail/command/rotateleftarmcommandtoken.java
package grail.command;

import grail.interfaces.CommandToken;
import grail.tokens.WordStoreToken;
import util.annotations.Tags;

@Tags({"rotateLeftArm"})
public class RotateLeftArmCommandToken extends WordStoreToken implements CommandToken {

	public RotateLeftArmCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/command/rotaterightarmcommandtoken.java
package grail.command;

import grail.interfaces.CommandToken;
import grail.tokens.WordStoreToken;
import util.annotations.Tags;

@Tags({"rotateRightArm"})
public class RotateRightArmCommandToken extends WordStoreToken implements CommandToken {

	public RotateRightArmCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/command/saycommandtoken.java
package grail.command;

import grail.interfaces.CommandToken;
import grail.tokens.WordStoreToken;
import util.annotations.Tags;

@Tags({"say"})

public class SayCommandToken extends WordStoreToken implements CommandToken {

	public SayCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/command/sleepcommandtoken.java
package grail.command;
import grail.interfaces.CommandToken;
import grail.tokens.WordStoreToken;
import util.annotations.Tags;

@Tags({"sleep"})
public class SleepCommandToken extends WordStoreToken implements CommandToken {

	public SleepCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/command/threadcommandtoken.java
package grail.command;
import grail.interfaces.CommandToken;
import grail.tokens.WordStoreToken;
import util.annotations.Tags;

@Tags({"thread"})
public class ThreadCommandToken extends WordStoreToken implements CommandToken {

	public ThreadCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/command/undocommandtoken.java
package grail.command;
import grail.interfaces.CommandToken;
import grail.tokens.WordStoreToken;
import util.annotations.Tags;

@Tags({"undo"})
public class UndoCommandToken extends WordStoreToken implements CommandToken {

	public UndoCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/command/waitcommandtoken.java
package grail.command;
import grail.interfaces.CommandToken;
import grail.tokens.WordStoreToken;
import util.annotations.Tags;

@Tags({"wait"})
public class WaitCommandToken extends WordStoreToken implements CommandToken {

	public WaitCommandToken(String input) {
		super(input);
		
	}

}
//END OF FILE
//START OF FILE: src/grail/commander/basiccommandinterpreter.java
package grail.commander;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import grail.animation.AnimationCommandObject;
import grail.animation.Animator;
import grail.animation.BasicAvatarAnimator;
import grail.animation.BasicLockstepAnimator;
import grail.animation.LockstepAnimator;
import grail.animation.LockstepCommandObject;
import grail.factories.SingletonsCreator;
import grail.helpers.ClearanceManager;
import grail.helpers.CommandParser;
import grail.model.APropertyListenerSupport;
import grail.model.PropertyListenerSupport;
import grail.scene.BridgeScene;
import util.annotations.ComponentWidth;
import util.annotations.EditablePropertyNames;
import util.annotations.ObserverRegisterer;
import util.annotations.ObserverTypes;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;


@Tags({"CommandInterpreter", "SignedMove", "ErrorResilient"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Command", "Errors"})
@EditablePropertyNames({"Command"})
public class BasicCommandInterpreter implements CommandInterpreter{
	private BridgeScene scene;
	private String currentCommand;
	private String errors;
	private Runnable currentCommandRunnable;
	private String walkCommand = "walk";
	private String clapCommand = "clap";
	private String marchCommand = "march";
	private CommandParser parse;
	protected PropertyListenerSupport propertyListenerSupport = new APropertyListenerSupport();
	private Animator arthurAnimator, galahadAnimator, lancelotAnimator, robinAnimator, guardAnimator;
	private LockstepAnimator arthurLock, galahadLock, lancelotLock, robinLock, guardLock;
	private ClearanceManager manager;
	private final int componentWidth = 400;
	
	public BasicCommandInterpreter(BridgeScene scene, ClearanceManager manager) {
		this.scene = scene;
		this.currentCommand = "";
		this.errors = "";
		this.manager = manager;	
		this.parse = SingletonsCreator.parserFactoryMethod();
		this.arthurAnimator = new BasicAvatarAnimator();
		this.galahadAnimator = new BasicAvatarAnimator();
		this.lancelotAnimator = new BasicAvatarAnimator();
		this.robinAnimator = new BasicAvatarAnimator();
		this.guardAnimator = new BasicAvatarAnimator();
		this.arthurLock = new BasicLockstepAnimator(manager);
		this.galahadLock = new BasicLockstepAnimator(manager);
		this.lancelotLock = new BasicLockstepAnimator(manager);
		this.robinLock = new BasicLockstepAnimator(manager);
		this.guardLock = new BasicLockstepAnimator(manager);
		}
	
	public BasicCommandInterpreter(BridgeScene scene) {
		this(scene, SingletonsCreator.broadcastingClearnaceManagerMethod());
	}
	
	public BasicCommandInterpreter() {
		this(SingletonsCreator.bridgeSceneFactoryMethod(), SingletonsCreator.broadcastingClearnaceManagerMethod());
	}

	
	@ComponentWidth(componentWidth)
	public String getCommand() {
		return currentCommand;
		
	}
	
	public void setCommand(String commandLine) {
		String oldCommand = this.currentCommand;
		this.currentCommand = commandLine;
		this.errors = "";
		
		parse.setCommandText(commandLine);
		this.currentCommandRunnable = parse.getCommandObject();
		this.currentCommandRunnable.run();
		this.errors = parse.getErrors();

		if (propertyListenerSupport != null) {
			propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this, "Command",oldCommand,this.currentCommand ));
			propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this, "Errors", null, this.errors));
		}
		
	}


	@Tags({"ErrorResilient"})
    @ComponentWidth(componentWidth)
	public String getErrors() {
		return this.errors;
	}
	
	
	@Tags({"asynchronousArthur"})
	public void asynchronousArthur() {
		final int distanceToWalk = 160;
		Runnable animateCommand = new AnimationCommandObject(this.arthurAnimator, walkCommand, this.scene.getArthur(), distanceToWalk);
		Thread thread = new Thread(animateCommand);
		thread.start();
	}

	@Tags({"asynchronousGalahad"})
	public void asynchronousGalahad() {
		final int distanceToWalk = 160;
		Runnable animateCommand = new AnimationCommandObject(this.galahadAnimator, walkCommand, this.scene.getGalahad(), distanceToWalk);
		Thread thread = new Thread(animateCommand);
		thread.start();
	}
	
	@Tags({"asynchronousLancelot"})
	public void asynchronousLancelot() {
		final int distanceToWalk = 300;
		final int sleepTime = 50;
		Runnable animateCommand = new AnimationCommandObject(this.lancelotAnimator, walkCommand, this.scene.getLancelot(), distanceToWalk,sleepTime);
		Thread thread = new Thread(animateCommand);
		thread.start();
	}
	
	@Tags({"asynchronousRobin"})
	public void asynchronousRobin() {
		final int distanceToWalk = 260;
		Runnable animateCommand = new AnimationCommandObject(this.robinAnimator, walkCommand, this.scene.getRobin(), distanceToWalk);
		Thread thread = new Thread(animateCommand);
		thread.start();
	}
	
	@Tags({"asynchronousGuard"})
	public void asynchronousGuard() {
		final int secondsToClap = 8;
		Runnable animateCommand = new AnimationCommandObject(this.guardAnimator, clapCommand, this.scene.getGuard(), secondsToClap);
		Thread thread = new Thread(animateCommand);
		thread.start();
	}
	
	@Tags({"waitingArthur"})
	public void waitingArthur() {
		final int distanceToWalk = 160;
		Runnable animateCommand = new AnimationCommandObject(this.arthurAnimator, this.manager, walkCommand, this.scene.getArthur(), distanceToWalk);
		Thread thread = new Thread(animateCommand);
		thread.start(); 
	}
	
	@Tags({"waitingGalahad"})
	public void waitingGalahad() {
		final int distanceToWalk = 160;
		Runnable animateCommand = new AnimationCommandObject(this.galahadAnimator, this.manager, walkCommand, this.scene.getGalahad(), distanceToWalk);
		Thread thread = new Thread(animateCommand);
		thread.start(); 
	}
	
	@Tags({"waitingLancelot"})
	public void waitingLancelot() {
		final int distanceToWalk = 160;
		Runnable animateCommand = new AnimationCommandObject(this.lancelotAnimator, this.manager, walkCommand, this.scene.getLancelot(), distanceToWalk);
		Thread thread = new Thread(animateCommand);
		thread.start(); 
	}
	
	@Tags({"waitingRobin"})
	public void waitingRobin() {
		final int distanceToWalk = 160;
		Runnable animateCommand = new AnimationCommandObject(this.robinAnimator, this.manager, walkCommand, this.scene.getRobin(), distanceToWalk);
		Thread thread = new Thread(animateCommand);
		thread.start(); 
	}
	
	@Tags({"start animation"})
	public void startAnimation() {
		this.manager.proceedAll();
	}
	
	@Tags({"lockstepArthur"})
	public void lockstepArthur() {
		final int distanceToMarch = 100;
		Runnable animateCommand = new LockstepCommandObject(this.arthurLock, marchCommand, this.scene.getArthur(), distanceToMarch);
		Thread thread = new Thread(animateCommand);
		thread.start();
	}
	
	@Tags({"lockstepLancelot"})
	public void lockstepLancelot() {
		final int distanceToMarch = 100;
		Runnable animateCommand = new LockstepCommandObject(this.lancelotLock, marchCommand, this.scene.getLancelot(), distanceToMarch);
		Thread thread = new Thread(animateCommand);
		thread.start();
	}
	
	@Tags({"lockstepGalahad"})
	public void lockstepGalahad() {
		final int distanceToMarch = 100;
		Runnable animateCommand = new LockstepCommandObject(this.galahadLock, marchCommand, this.scene.getGalahad(), distanceToMarch);
		Thread thread = new Thread(animateCommand);
		thread.start();
	}
	
	@Tags({"lockstepRobin"})
	public void lockstepRobin() {
		final int distanceToMarch = 100;
		Runnable animateCommand = new LockstepCommandObject(this.robinLock, marchCommand, this.scene.getRobin(), distanceToMarch);
		Thread thread = new Thread(animateCommand);
		thread.start();
	}
	
	@Tags({"lockstepGuard"})
	public void lockstepGuard() {
		final int timesToClap = 5;
		Runnable animateCommand = new LockstepCommandObject(this.guardLock, clapCommand, this.scene.getGuard(), timesToClap);
		Thread thread = new Thread(animateCommand);
		thread.start();
	}
	

	
	@ObserverRegisterer(ObserverTypes.PROPERTY_LISTENER)
	public void addPropertyChangeListener(PropertyChangeListener arg0) {
		propertyListenerSupport.addElement(arg0);
		
	}
	
	
	
}
//END OF FILE
//START OF FILE: src/grail/commander/commandinterpreter.java
package grail.commander;
import util.models.PropertyListenerRegisterer;

public interface CommandInterpreter extends PropertyListenerRegisterer  {
	public String getCommand();
	public void setCommand(String commandLine);
	public String getErrors();
	public void asynchronousArthur();
	public void asynchronousGalahad();
	public void asynchronousLancelot();
	public void asynchronousRobin();
	public void asynchronousGuard();
	public void waitingArthur();
	public void waitingGalahad();
	public void waitingLancelot();
	public void waitingRobin();
	public void startAnimation();
	public void lockstepArthur();
	public void lockstepLancelot();
	public void lockstepGalahad();
	public void lockstepRobin();
	public void lockstepGuard();
}
//END OF FILE
//START OF FILE: src/grail/controllers/basicbridgecontroller.java
package grail.controllers;

import grail.avatar.Avatar;
import grail.factories.SingletonsCreator;
import grail.paint.AObservablePainter;
import grail.paint.ObservablePainter;
import grail.scene.BridgeScene;
import util.annotations.Tags;
import java.awt.Component;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;

@Tags({"BridgeSceneController"})
public class BasicBridgeController implements BridgeController{
	private BridgeScene aScene;
	private int clickedX, clickedY;
	private Avatar arthur,galahad,robin,lancelot;
	private ObservablePainter aModel;
	
	public BasicBridgeController(BridgeScene scene) {
		this(scene, new AObservablePainter());
	}
	
	
	public BasicBridgeController(BridgeScene scene, ObservablePainter model) {
		this.aScene = scene;
		setModel(model);
		this.clickedX = 0;
		this.clickedY = 0;
		this.arthur = scene.getArthur();
		this.galahad = scene.getGalahad();
		this.robin = scene.getRobin();
		this.lancelot = scene.getLancelot();
	}
	
	public BasicBridgeController() {
		this(SingletonsCreator.bridgeSceneFactoryMethod());
	}

	
	public void keyTyped(KeyEvent e) {
		char pressedKey = e.getKeyChar();
		processKeyInput(pressedKey);
	}
	
	public void setModel(ObservablePainter model) {
		this.aModel = model;
		((Component) model).addMouseListener(this);
		((Component) model).addKeyListener(this);
	}
	
	public ObservablePainter getModel() {return this.aModel;}

	
	public void keyPressed(KeyEvent e) {}

	
	public void keyReleased(KeyEvent e) {}

	
	public void mouseClicked(MouseEvent e) {
		this.clickedX = e.getX();
		this.clickedY = e.getY();
	}

	
	public void mousePressed(MouseEvent e) {}

	
	public void mouseReleased(MouseEvent e) {}

	
	public void mouseEntered(MouseEvent e) {}

	
	public void mouseExited(MouseEvent e) {}
	
	private void processKeyInput(char key) {
		if (key == 'a') {
			this.arthur.setLocation(clickedX, clickedY);
		} else if (key == 'l') {
			this.lancelot.setLocation(clickedX, clickedY);
		} else if (key == 'g') {
			this.galahad.setLocation(clickedX, clickedY);
		} else if (key == 'r') {
			this.robin.setLocation(clickedX, clickedY);
		} else if (key == 'o') {
			this.aScene.setOriginalPositions();
		}
	}

}
//END OF FILE
//START OF FILE: src/grail/controllers/bridgecontroller.java
package grail.controllers;

import java.awt.event.KeyListener;
import java.awt.event.MouseListener;

import grail.paint.ObservablePainter;

public interface BridgeController extends MouseListener, KeyListener  {
	public void setModel(ObservablePainter model);
	public ObservablePainter getModel();
}
//END OF FILE
//START OF FILE: src/grail/demo/assignment12demo.java
package grail.demo;

import java.awt.Component;
import java.beans.PropertyChangeEvent;
import javax.swing.JFrame;
import bus.uigen.OEFrame;
import bus.uigen.ObjectEditor;
import bus.uigen.widgets.TextFieldSelector;
import grail.commander.CommandInterpreter;
import grail.controllers.BasicBridgeController;
import grail.factories.PersonalizedSwingTextFieldFactory;
import grail.factories.SingletonsCreator;
import grail.helpers.ClearanceManager;
import grail.helpers.ComponentBuilder;
import grail.paint.ObservablePainter;
import grail.scene.BridgeScene;
import grail.toolkit.BasicCommandController;
import grail.toolkit.ToolkitCommandViewer;
import grail.toolkit.AdvancedCommandViewer;
import util.annotations.PropertyNames;
import util.misc.ThreadSupport;

@PropertyNames({"Progress"})
public class Assignment12Demo extends BasicDemo implements TwelveDemo {
	int progress;
	private final String undo = "undo";
	private final String redo = "redo";
	
	public Assignment12Demo() {
		
	}
	
	public void run() {
		final int frameWidth = 1600;
		final int frameHeight = 1000;
		final int interpreterViewLocation = 600;
		progress = 0;
		
		//allows the factory to be set. 
		ObjectEditor.initialize();
		TextFieldSelector.setTextFieldFactory(new PersonalizedSwingTextFieldFactory());
		
		//build using SingletonCreator inside ComponenetBuilder
		ObservablePainter singleComponentModel = ComponentBuilder.buildObservablePainterFromScene();
		
		(new BasicBridgeController()).setModel(singleComponentModel);
		
		JFrame frame = new JFrame("Window");	
		frame.add(((Component) singleComponentModel));
		frame.setSize(frameWidth, frameHeight);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setVisible(true);
		
		
		AdvancedCommandViewer commandView = new ToolkitCommandViewer();
		new BasicCommandController(commandView);
		commandView.placeFrameOnTop();
		commandView.getFrame().setLocation(0, interpreterViewLocation);
		
		final int interpreterX = 1200;
		final int interpreterY = 700;
		final int editor2Width = 490;
		final int editor2Height = 125;
		OEFrame editor2 = ObjectEditor.edit(SingletonsCreator.commandInterpreterFactoryMethod());
		editor2.setLocation(interpreterX, interpreterY);
		editor2.setSize(editor2Width, editor2Height);
		
		
		final int clearanceX = 1200;
		final int clearanceY = 100;
		final int clearanceWidth = 325;
		final int clearanceHeight = 110;
		OEFrame editor3 = ObjectEditor.edit(SingletonsCreator.broadcastingClearnaceManagerMethod());
		editor3.setLocation(clearanceX, clearanceY);
		editor3.setSize(clearanceWidth, clearanceHeight);
		
		
		animateScene(SingletonsCreator.bridgeSceneFactoryMethod(), SingletonsCreator.commandInterpreterFactoryMethod(), SingletonsCreator.broadcastingClearnaceManagerMethod());
		
	}

	
	private void animateScene(BridgeScene scene, CommandInterpreter command, ClearanceManager manager) {
		final int reasonableWaitTime = 2000;
		final int waitingAnimationTime = 8000;
		final int lockstepAnimationTime = 12000;
		int progressOutOfFive = 0;
		
		//demonstrate wait
		command.waitingArthur();
		command.waitingGalahad();
		command.waitingLancelot();
		command.waitingRobin();
		scene.getGuard().setBasicText("Demonstrate waitAnimation");
		scene.getGalahad().setBasicText("Press ProceedAll to animate.");
		manager.waitForProceed();
		ThreadSupport.sleep(waitingAnimationTime);
		updateProgressBar(++progressOutOfFive);
		
		//demonstrate lockstep
		scene.setOriginalPositions();
		scene.getGuard().setBasicText("Time to demonstrate Lockstep!");
		scene.getArthur().setBasicText("We Move with claping");
		scene.getGalahad().setBasicText("Lets March!");
		ThreadSupport.sleep(reasonableWaitTime);
		command.lockstepArthur();
		command.lockstepGalahad();
		command.lockstepLancelot();
		command.lockstepRobin();
		command.lockstepGuard();
		ThreadSupport.sleep(lockstepAnimationTime);
		updateProgressBar(++progressOutOfFive);
		
		//demonstrate commands
		scene.setOriginalPositions();
		scene.getGuard().setBasicText("Now we will show each command going into the command interpreter.");
		scene.getLancelot().setBasicText("Press ProceedAll to see each command go in.");
		manager.waitForProceed();
		command.setCommand("approach arthur");
		manager.waitForProceed();
		command.setCommand("say \"Hello from the guard!\"");
		manager.waitForProceed();
		command.setCommand("say \"I'm passing!\"");
		manager.waitForProceed();
		command.setCommand("pass");
		manager.waitForProceed();
		command.setCommand("approach galahad");
		manager.waitForProceed();
		command.setCommand("say \"I'm Failing you!\"");
		manager.waitForProceed();
		command.setCommand("say \"What?!\"");
		manager.waitForProceed();
		command.setCommand("fail");
		manager.waitForProceed();
		scene.getGalahad().rebuild();
		scene.setOriginalPositions();
		scene.getGalahad().setBasicText("I'm Back!");
		scene.getArthur().setBasicText("I'm back too!");
		scene.getGuard().setBasicText("Time to demo Beats!");
		manager.waitForProceed();
		command.setCommand("define guardArmsIn { rotateLeftArm guard 7 rotateRightArm guard - 7 }");
		manager.waitForProceed();
		command.setCommand("define guardArmsOut { rotateLeftArm guard - 7 rotateRightArm guard 7 }");
		manager.waitForProceed();
		command.setCommand("define beat { call guardArmsIn sleep 1000 proceedAll call guardArmsOut sleep 1000 proceedAll }");
		manager.waitForProceed();
		command.setCommand("define beats repeat 5 call beat");
		command.lockstepArthur();
		command.lockstepGalahad();
		command.lockstepRobin();
		command.lockstepLancelot();
		scene.getGuard().setBasicText("The Next ProceedAll Will run the different beats");
		manager.waitForProceed();
		command.setCommand("thread beats");
		scene.getGuard().setBasicText("Doing Beats");
		ThreadSupport.sleep(lockstepAnimationTime);
		updateProgressBar(++progressOutOfFive);
		
		//Undo and Redo
		scene.setOriginalPositions();
		scene.getGuard().setBasicText("Next we will show basic commands with undo and redo");
		scene.getLancelot().setBasicText("Press ProceedAll to go through commands");
		manager.waitForProceed();
		scene.getGuard().setBasicText("Keep pushing ProceedAll!");
		scene.getLancelot().setBasicText("I'll show undo and redo");
		command.setCommand("move lancelot 100 100");
		manager.waitForProceed();
		command.setCommand(undo);
		manager.waitForProceed();
		command.setCommand(redo);
		manager.waitForProceed();
		command.setCommand(undo);
		manager.waitForProceed();
		scene.getArthur().setBasicText("We all move!");
		scene.getGalahad().setBasicText("Yay!");
		scene.getLancelot().setBasicText("We all move a lot!");
		scene.getRobin().setBasicText("Awesome!");
		command.setCommand("{ rotateRightArm arthur 5 rotateLeftArm arthur 5 move galahad 100 100 move lancelot 100 100 move robin 100 100 }");
		manager.waitForProceed();
		command.setCommand(undo);
		manager.waitForProceed();
		command.setCommand(redo);
		manager.waitForProceed();
		command.setCommand(undo);
		manager.waitForProceed();
		scene.getGuard().setBasicText("All done! Time to show Errors. Press ProceedAll");
		updateProgressBar(++progressOutOfFive);
		
		//show how errors are handled
		manager.waitForProceed();
		scene.getGuard().setBasicText("See how errors are handled. Keep pushing ProceedAll");
		command.setCommand("Invalid command and %$%#%@ token");
		manager.waitForProceed();
		command.setCommand("move arthur 100 turkey  bad syntax in move");
		manager.waitForProceed();
		command.setCommand("rotateRightArm BillyBob 100 100 bad syntax avatar does not exist");
		manager.waitForProceed();
		command.setCommand("move galahad 100 100 excess token and illegal tokens ign@red.");
		manager.waitForProceed();
		command.setCommand(undo);
		scene.getGalahad().setBasicText("Moving back");
		manager.waitForProceed();
		scene.getGuard().setBasicText("All Done with Demo! Enter commands to see it working.");
		command.setCommand("print");
		updateProgressBar(++progressOutOfFive);
		
	}
	
	private void updateProgressBar(int number) {
		final int progressIncrement = 20;
		int oldVal = this.progress;
		this.progress = number * progressIncrement;
		if (propertyListener != null) {
			propertyListener.notifyAllListeners(new PropertyChangeEvent(this,"Progress", oldVal, this.progress));
		}
		
	}
	
	
}
//END OF FILE
//START OF FILE: src/grail/demo/basicdemo.java
package grail.demo;

import java.beans.PropertyChangeListener;

import grail.model.APropertyListenerSupport;
import grail.model.PropertyListenerSupport;

public class BasicDemo implements Demo {
	PropertyListenerSupport propertyListener;
	
	public BasicDemo() {
		this.propertyListener = new APropertyListenerSupport();
	}
	
	public void run() {
		System.out.println("Default Demo. Nothing was run.");
	}

	@Override
	public void addPropertyChangeListener(PropertyChangeListener arg0) {
		this.propertyListener.addElement(arg0);
		
	}

}
//END OF FILE
//START OF FILE: src/grail/demo/demo.java
package grail.demo;

import util.models.PropertyListenerRegisterer;

public interface Demo extends PropertyListenerRegisterer{
	public void run();
}
//END OF FILE
//START OF FILE: src/grail/demo/twelvedemo.java
package grail.demo;

import util.models.PropertyListenerRegisterer;

public interface TwelveDemo extends PropertyListenerRegisterer, Demo{

}
//END OF FILE
//START OF FILE: src/grail/draw/interfaces/angleshape.java
package grail.draw.interfaces;

import java.awt.Color;

import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Angle"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
public interface AngleShape extends MutableShape{
		public RotatingShape getLeftLine();
		public RotatingShape getRightLine();
		public void move(int x, int y);
		public void setRadius(double radius);
		public void setAngle(double angle);
		public void setColor(Color newColor);
		public Color getColor();
		public void rotate(int unit);
		public double getRadius();
		public double getAngle();
		public void scale(double scaleFactor);
}
//END OF FILE
//START OF FILE: src/grail/draw/interfaces/bridgemoat.java
package grail.draw.interfaces;

public interface BridgeMoat extends MutableShape {
	public RotatingShape getMoatLeft();
	public RotatingShape getMoatRight();
	public RotatingShape getBridgeBottom();
	public RotatingShape getBridgeTop();
	public RotatingShape getPlankOne();
	public RotatingShape getPlankTwo();
	public RotatingShape getPlankThree();
	public RotatingShape getPlankFour();
	public RotatingShape getPlankFive();
	public RotatingShape getPlankSix();
	public void setSize(int width, int height);
	public void setLocation(int x, int y);
	public void move(int x, int y);
	public int getFallZoneX();
	public int getFallZoneY();
}
//END OF FILE
//START OF FILE: src/grail/draw/interfaces/colormutableshape.java
package grail.draw.interfaces;

import java.awt.Color;

public interface ColorMutableShape extends MutableShape{
	public void setColor(Color newColor);
	public Color getColor();
	public boolean getFilled();
	public void setFilled(boolean input);
}
//END OF FILE
//START OF FILE: src/grail/draw/interfaces/coloredshape.java
package grail.draw.interfaces;

import java.awt.Color;

import util.annotations.Tags;

@Tags({"BoundedShape"})
public interface ColoredShape extends Shape{
	public Color getColor();
	public void setColor(Color newColor);
	public boolean getFilled();
	public void setFilled(boolean filled);
}
//END OF FILE
//START OF FILE: src/grail/draw/interfaces/imageshape.java
package grail.draw.interfaces;

import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.IMAGE_PATTERN)
public interface ImageShape extends MutableShape {
	public String getImageFileName();  
    public void setImageFileName(String newName);
}
//END OF FILE
//START OF FILE: src/grail/draw/interfaces/locator.java
package grail.draw.interfaces;
import util.annotations.Tags;
import util.models.PropertyListenerRegisterer;

@Tags({"Locatable"})
public interface Locator extends PropertyListenerRegisterer {
	public int getX();
	public void setX(int newX);
	public int getY();
	public void setY(int newY);
}
//END OF FILE
//START OF FILE: src/grail/draw/interfaces/mutableshape.java
package grail.draw.interfaces;

public interface MutableShape extends Shape {
    public void setHeight(int newHeight);
    public void setWidth(int newWidth);

}
//END OF FILE
//START OF FILE: src/grail/draw/interfaces/ovalshape.java
package grail.draw.interfaces;

public interface OvalShape extends ColorMutableShape{
	public boolean getFilled();
	public void setFilled(boolean isFilled);
}
//END OF FILE
//START OF FILE: src/grail/draw/interfaces/platform.java
package grail.draw.interfaces;

import grail.avatar.Avatar;

public interface Platform extends OvalShape {
	public void setLocation(int x, int y);
	public OvalShape getPlatform();
	public OvalShape getShadow();
	public int getAvatarX(Avatar aAvatar);
	public int getAvatarY(Avatar aAvatar);
	public void move(int x, int y);
}
//END OF FILE
//START OF FILE: src/grail/draw/interfaces/point.java
package grail.draw.interfaces;

public interface Point extends Locator {

}
//END OF FILE
//START OF FILE: src/grail/draw/interfaces/rectangle.java
package grail.draw.interfaces;

public interface Rectangle extends ColorMutableShape{

}
//END OF FILE
//START OF FILE: src/grail/draw/interfaces/rotatingshape.java
package grail.draw.interfaces;

import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.LINE_PATTERN)
public interface RotatingShape extends ColoredShape {
	public void setRadius(double val);
	public double getRadius();
	public double getAngle();
	public void setAngle(double val);
	public void rotate(int units);
}
//END OF FILE
//START OF FILE: src/grail/draw/interfaces/shape.java
package grail.draw.interfaces;

import util.annotations.Tags;

@Tags({"BoundedShape"})
public interface Shape extends Locator{
	public int getHeight();
	public int getWidth();
}
//END OF FILE
//START OF FILE: src/grail/draw/interfaces/stringshape.java
package grail.draw.interfaces;

import java.awt.Color;

public interface StringShape extends Locator{

	public String getText();
	public void setText(String text);
	public Color getTextColor();
	public void setTextColor(Color newColor);
}
//END OF FILE
//START OF FILE: src/grail/draw/objects/basicangleshape.java
package grail.draw.objects;

import java.awt.Color;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

import grail.draw.interfaces.AngleShape;
import grail.draw.interfaces.RotatingShape;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Angle"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"X", "Y", "Height", "Width", "Radius", "Angle", "LeftLine", "RightLine" , "Color"})
@EditablePropertyNames({"X", "Y", "Height", "Width", "Radius", "Angle", "Color"})
public class BasicAngleShape extends BasicMutableShape implements AngleShape {
	private RotatingShape leftLine, rightLine;
	private double radius, angle;
	private Color color;
	
	public BasicAngleShape() {
		this(0,0);
	}
	
	public BasicAngleShape(int initialX, int initialY) {
		super();
		final double startingRadius = 50;
		final double leftStartingAngle = Math.PI;
		final double rightStartingAngle = 0;
		
		x = initialX;
		y = initialY;
		leftLine = new LineRotatingShape(x, y, startingRadius, leftStartingAngle);
		rightLine = new LineRotatingShape(x, y, startingRadius, rightStartingAngle);
		this.height = leftLine.getHeight();
		this.width = rightLine.getWidth() + leftLine.getWidth();
		setRadius(startingRadius);
		setAngle(rightStartingAngle);
		setColor(Color.BLACK);
	}


	
	public void setX(int x) {
		super.setX(x);
		leftLine.setX(this.x);
		rightLine.setX(this.x);
	}


	
	public void setY(int y) {
		super.setY(y);
		leftLine.setY(this.y);
		rightLine.setY(this.y);

	}
	
	public RotatingShape getLeftLine() {
		return leftLine;
	}

	
	public RotatingShape getRightLine() {
		return rightLine;
	}

	
	@Tags({"move"})
	public void move(int x, int y) {
		this.x = this.x + x;
		this.y = this.y + y;
		setX(this.x);
		setY(this.y);
	}
	
	public void setRadius(double radius) {
		double oldRadius = this.radius;
		this.radius = radius;
		leftLine.setRadius(radius);
		rightLine.setRadius(radius);
		if (this.propertyListenerSupport != null){
		this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this, "Radius", oldRadius, this.radius));
		}
	}
	
	public void setAngle(double angle) {
		double oldAngle = this.angle;
		this.angle = angle;
		double halfAngle = angle/2;
		leftLine.setAngle(halfAngle + Math.PI);
		rightLine.setAngle(-halfAngle);
		if (this.propertyListenerSupport != null){
		this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this, "Angle", oldAngle, this.angle));
		}
	}
	
	public void rotate(int units) {
		int unitToMoveRight = -units;
		int unitsToMoveLeft = units;
		rightLine.rotate(unitToMoveRight);
		leftLine.rotate(unitsToMoveLeft);
	}

	
	public void setHeight(int height) {
		int oldHeight = this.height;
		int halfWidth = this.width/2;
		double radius = (double) Math.sqrt((halfWidth * halfWidth) + (height * height));
		this.leftLine.setRadius(radius);
		this.rightLine.setRadius(radius);
		double angle = (double) Math.sinh(height/radius);
		this.rightLine.setAngle(-angle);
		this.leftLine.setAngle(Math.PI + angle);
		this.height = (this.leftLine.getHeight() >= this.rightLine.getHeight())? Math.abs(leftLine.getHeight()):Math.abs(this.rightLine.getHeight());
		if (this.propertyListenerSupport != null){
		this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this, "Height", oldHeight, this.height));
		}
		
	}

	
	public void setWidth(int width) {
		int oldWidth = this.width;
		this.width = width;
		int halfWidth = this.width/2;
		double radius = (double) Math.sqrt((halfWidth * halfWidth) + (height * height));
		this.leftLine.setRadius(radius);
		this.rightLine.setRadius(radius);
		double angle = (double) Math.sinh(height/radius);
		this.rightLine.setAngle(-angle);
		this.leftLine.setAngle(Math.PI + angle);
		this.width = Math.abs(this.leftLine.getWidth()) + Math.abs(this.rightLine.getWidth());
		if (this.propertyListenerSupport != null){
		this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this, "Width", oldWidth, this.width));
		}
		
	}
	
	@Override
	public int getWidth() {
		return Math.abs(this.leftLine.getWidth()) + Math.abs(this.rightLine.getWidth());
	}
	
	@Override
	public int getHeight() {
		return (this.leftLine.getHeight() >= this.rightLine.getHeight())? Math.abs(leftLine.getHeight()):Math.abs(this.rightLine.getHeight());
	}
	
	public double getRadius() {
		return radius;
	}

	
	public double getAngle() {
		return angle;
	}

	
	public Color getColor() {
		return color;
	}

	
	public void setColor(Color newColor) {
		Color oldColor = this.color;
		this.color = newColor;
		this.leftLine.setColor(newColor);
		this.rightLine.setColor(newColor);
		if (this.propertyListenerSupport != null){
		this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this, "Color", oldColor, this.color));
		}
		
	}

	
	public void scale(double scaleFactor) {
		this.rightLine.setRadius(this.rightLine.getRadius() * scaleFactor);
		this.leftLine.setRadius(this.leftLine.getRadius() * scaleFactor);
		
	}
	
	public static void addListenersToSubshapes(AngleShape shape, PropertyChangeListener listener) {
		shape.getLeftLine().addPropertyChangeListener(listener);
		shape.getRightLine().addPropertyChangeListener(listener);
	}

}
//END OF FILE
//START OF FILE: src/grail/draw/objects/basicbridgemoat.java
package grail.draw.objects;

import java.beans.PropertyChangeListener;

import grail.draw.interfaces.BridgeMoat;
import grail.draw.interfaces.RotatingShape;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"X", "Y", "Width", "Height", "MoatLeft", "MoatRight", "BridgeBottom", "BridgeTop","PlankOne", "PlankTwo", "PlankThree", "PlankFour", "PlankFive", "PlankSix", "FallZoneX", "FallZoneY"})
@EditablePropertyNames({"X", "Y", "Width", "Height"})
public class BasicBridgeMoat extends BasicMutableShape implements BridgeMoat{
	private RotatingShape moatLeft, moatRight, bridgeTop, bridgeBottom, plankOne, plankTwo, plankThree, plankFour, plankFive, plankSix;
	
	public BasicBridgeMoat(int x, int y) {
		super();
		final int defaultHeight = 400;
		final int defaultWidth = 200;
		this.x = x;
		this.y = y;
		this.height = defaultHeight;
		this.width = defaultWidth;
		this.moatLeft = new LineRotatingShape();
		this.moatRight = new LineRotatingShape();
		this.bridgeTop = new LineRotatingShape();
		this.bridgeBottom = new LineRotatingShape();
		this.plankOne = new LineRotatingShape();
		this.plankTwo = new LineRotatingShape();
		this.plankThree = new LineRotatingShape();
		this.plankFour = new LineRotatingShape();
		this.plankFive = new LineRotatingShape();
		this.plankSix = new LineRotatingShape();
		
		buildBridgeMoat(this.x, this.y,this.width, this.height);
	}
	
	private void buildBridgeMoat(int xLocation, int yLocation, int widthInt, int heightInt) {
		final double width = widthInt;
		final double height = heightInt;
		final double halfWidth = ((double)width)/2;
		final int moatRightStartX =(int) (xLocation + width);
		final int moatLeftStartX = (int) (xLocation + width/2);
		final int moatRightStartY = yLocation;
		final int moatLeftStartY = yLocation;
		final double moatRadius = (Math.sqrt(halfWidth * halfWidth + height * height));
		final double moatAngle = (Math.PI - Math.atan(height/halfWidth));
		this.moatLeft.setX(moatLeftStartX);
		this.moatLeft.setY(moatLeftStartY);
		this.moatLeft.setRadius(moatRadius);
		this.moatLeft.setAngle(moatAngle);
		this.moatRight.setX(moatRightStartX);
		this.moatRight.setY(moatRightStartY);
		this.moatRight.setRadius(moatRadius);
		this.moatRight.setAngle(moatAngle);
		
		
		final double widthDivision = 6;
		final double heightDivision = 3;
		final double sixthOfWidth = width/widthDivision;
		final double thirdOfHeight = height/heightDivision;
		final double fiveSixthOfWidth = 5 * sixthOfWidth;
		final int bridgeTopX = (int) (xLocation + (sixthOfWidth));
		final int bridgeTopY = (int) (yLocation + (thirdOfHeight));
		final double bridgeTopRadius = (fiveSixthOfWidth);
		final double bridgeTopAngle = 0;
		this.bridgeTop.setX(bridgeTopX);
		this.bridgeTop.setY(bridgeTopY);
		this.bridgeTop.setRadius(bridgeTopRadius);
		this.bridgeTop.setAngle(bridgeTopAngle);
		
		final double twoThirdsOfHeight = 2 * thirdOfHeight;
		final int bridgeBottomX = (xLocation);
		final int bridgeBottomY = (int) (yLocation + (twoThirdsOfHeight));
		final double bridgeBottomRadius = (fiveSixthOfWidth);
		final double bridgeBottomAngle = 0;
		this.bridgeBottom.setX(bridgeBottomX);
		this.bridgeBottom.setY(bridgeBottomY);
		this.bridgeBottom.setRadius(bridgeBottomRadius);
		this.bridgeBottom.setAngle(bridgeBottomAngle);
		
	
		
		int plankNumber = 0;
		int plankLineX =(int) (xLocation + plankNumber * (sixthOfWidth));
		final int plankLineY =(int) (yLocation + (twoThirdsOfHeight));
		final double plankLineRadius = (Math.sqrt(Math.pow(thirdOfHeight, 2) + Math.pow(sixthOfWidth, 2)));
		final double plankAngle = (-(Math.atan((thirdOfHeight)/(sixthOfWidth))));
		this.plankOne.setX(plankLineX);
		this.plankOne.setY(plankLineY);
		this.plankOne.setRadius(plankLineRadius);
		this.plankOne.setAngle(plankAngle);
		
		plankNumber++;
		plankLineX = (int)(xLocation + plankNumber * (sixthOfWidth));
		this.plankTwo.setX(plankLineX);
		this.plankTwo.setY(plankLineY);
		this.plankTwo.setRadius(plankLineRadius);
		this.plankTwo.setAngle(plankAngle);

		plankNumber++;
		plankLineX = (int)(xLocation + plankNumber * (sixthOfWidth));
		this.plankThree.setX(plankLineX);
		this.plankThree.setY(plankLineY);
		this.plankThree.setRadius(plankLineRadius);
		this.plankThree.setAngle(plankAngle);
		
		plankNumber++;
		plankLineX = (int) (xLocation + plankNumber * (sixthOfWidth));
		this.plankFour.setX(plankLineX);
		this.plankFour.setY(plankLineY);
		this.plankFour.setRadius(plankLineRadius);
		this.plankFour.setAngle(plankAngle);
		
		plankNumber++;
		plankLineX = (int)(xLocation + plankNumber * (sixthOfWidth));
		this.plankFive.setX(plankLineX);
		this.plankFive.setY(plankLineY);
		this.plankFive.setRadius(plankLineRadius);
		this.plankFive.setAngle(plankAngle);
		
		plankNumber++;
		plankLineX = (int)(xLocation + plankNumber * (sixthOfWidth));
		this.plankSix.setX(plankLineX);
		this.plankSix.setY(plankLineY);
		this.plankSix.setRadius(plankLineRadius);
		this.plankSix.setAngle(plankAngle);
			
	}

	public BasicBridgeMoat() {
		this(0,0);
	}
	
	public void setHeight(int newHeight) {
		this.height = newHeight;
		buildBridgeMoat(this.x, this.y, this.width, this.height);
	}



	
	public void setWidth(int newWidth) {
		this.width = newWidth;
		buildBridgeMoat(this.x, this.y, this.width, this.height);
		
	}

	
	public void setX(int x) {
		this.x = x;
		buildBridgeMoat(this.x, this.y, this.width, this.height);
	}


	
	public void setY(int y) {
		this.y = y;
		buildBridgeMoat(this.x, this.y, this.width, this.height);
	}

	
	public RotatingShape getMoatLeft() {
		return this.moatLeft;
	}

	
	public RotatingShape getMoatRight() {
		return this.moatRight;
	}

	
	public RotatingShape getBridgeBottom() {
		return this.bridgeBottom;
	}

	
	public RotatingShape getBridgeTop() {
		return this.bridgeTop;
	}

	
	public RotatingShape getPlankOne() {
		return this.plankOne;
	}

	
	public RotatingShape getPlankTwo() {
		return this.plankTwo;
	}

	
	public RotatingShape getPlankThree() {
		return this.plankThree;
	}

	
	public RotatingShape getPlankFour() {
		return this.plankFour;
	}

	
	public RotatingShape getPlankFive() {
		return this.plankFive;
	}

	
	public void setSize(int width, int height) {
		this.width = width;
		this.height = height;
		buildBridgeMoat(this.x, this.y, this.width, this.height);
		
	}

	
	public void setLocation(int x, int y) {
		this.x = x;
		this.y = y;
		buildBridgeMoat(this.x, this.y, this.width, this.height);
	}

	
	public RotatingShape getPlankSix() {
		return this.plankSix;
	}

	
	public void move(int x, int y) {
		this.x = this.x + x;
		this.y = this.y + y;
		buildBridgeMoat(this.x, this.y, this.width, this.height);	
	}

	
	public int getFallZoneX() {
		final int sectionSize = 3;
		final int twoThirdsOfWidth = 2*this.width/sectionSize;
		return this.x + Math.abs(twoThirdsOfWidth);
	}

	
	public int getFallZoneY() {
		final int sectionSize = 8;
		final int eightOfHeight = this.height / sectionSize;
		return this.y + Math.abs(eightOfHeight); 
	}
	
	public static void addListenerToSubShapes(BridgeMoat shape, PropertyChangeListener listener) {
		shape.getMoatLeft().addPropertyChangeListener(listener);
		shape.getMoatRight().addPropertyChangeListener(listener);
		shape.getBridgeBottom().addPropertyChangeListener(listener);
		shape.getBridgeTop().addPropertyChangeListener(listener);
		shape.getPlankOne().addPropertyChangeListener(listener);
		shape.getPlankTwo().addPropertyChangeListener(listener);
		shape.getPlankThree().addPropertyChangeListener(listener);
		shape.getPlankFour().addPropertyChangeListener(listener);
		shape.getPlankFive().addPropertyChangeListener(listener);
		shape.getPlankSix().addPropertyChangeListener(listener);
	}

	

}
//END OF FILE
//START OF FILE: src/grail/draw/objects/basiccolormutableshape.java
package grail.draw.objects;

import java.awt.Color;
import java.beans.PropertyChangeEvent;
import grail.draw.interfaces.ColorMutableShape;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;

@PropertyNames({"X", "Y", "Height", "Width", "Color", "Filled"})
@EditablePropertyNames({"X", "Y", "Height", "Width", "Color", "Filled"})
public abstract class BasicColorMutableShape extends BasicMutableShape implements ColorMutableShape{
	protected Color color;
	protected boolean filled;
	
	public BasicColorMutableShape() {
		super();
		this.color = Color.BLACK;
		this.filled = false;
	}

	
	public void setColor(Color newColor) {
		Color oldVal = this.color;
		this.color = newColor;
		if (this.propertyListenerSupport != null) {
			this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent (this,"Color", oldVal, this.color ));
		}
		
	}

	
	public Color getColor() {
		return color;
	}
	

	
	public boolean getFilled() {
		return this.filled;
	}

	
	public void setFilled(boolean isFilled) {
		boolean oldVal = this.filled;
		this.filled = isFilled;
		if (this.propertyListenerSupport != null) {
			this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent (this,"Filled", oldVal, this.filled ));
		}
	}

}
//END OF FILE
//START OF FILE: src/grail/draw/objects/basiccoloredshape.java
package grail.draw.objects;

import java.awt.Color;
import java.beans.PropertyChangeEvent;
import grail.draw.interfaces.ColoredShape;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;


@PropertyNames({"X", "Y", "Width", "Height", "Color", "Filled"})
@EditablePropertyNames({"X", "Y", "Color", "Filled"})
public abstract class BasicColoredShape extends BasicShape implements ColoredShape{
	protected Color color;
	protected boolean filled;
	
	public BasicColoredShape() {
		super();
		this.color = Color.BLACK;
		this.filled = false;
	}

	
	public Color getColor() {
		return this.color;
	}

	
	public void setColor(Color newColor) {
		Color oldVal = this.color;
		this.color = newColor;
		if (this.propertyListenerSupport != null) {
			this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent (this,"Color", oldVal, this.color ));
		}
		
	}
	
	public boolean getFilled() {
		return this.filled;
	}

	
	public void setFilled(boolean isFilled) {
		boolean oldVal = this.filled;
		this.filled = isFilled;
		if (this.propertyListenerSupport != null) {
			this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent (this,"Filled", oldVal, this.filled ));
		}
	}	

}
//END OF FILE
//START OF FILE: src/grail/draw/objects/basicimageshape.java
package grail.draw.objects;

import java.beans.PropertyChangeEvent;

import javax.swing.Icon;
import javax.swing.ImageIcon;
import grail.draw.interfaces.ImageShape;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.IMAGE_PATTERN)
@PropertyNames({"Height", "Width", "X", "Y","ImageFileName"})
@EditablePropertyNames({"Height", "Width", "X", "Y", "ImageFileName"})
public class BasicImageShape extends BasicMutableShape implements ImageShape {
	private String imageFileName;
	private Icon image;
	
	public BasicImageShape(String imageFileName) {
		super();
		this.imageFileName = imageFileName;
		try {
			image = new ImageIcon(imageFileName);
			this.height = image.getIconHeight();
			this.width = image.getIconWidth();
		} catch (Exception e) {
			System.out.println("The image was not found!!");
		}

	}


	
	public String getImageFileName() {
		return imageFileName;
	}

	
	public void setImageFileName(String newName) {
		String oldFileName = this.imageFileName;
		this.imageFileName = newName;
		if (this.propertyListenerSupport != null) {
			this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent (this,"ImageFileName", oldFileName, this.imageFileName ));
		}
		
	}

}
//END OF FILE
//START OF FILE: src/grail/draw/objects/basiclocator.java
package grail.draw.objects;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

import grail.draw.interfaces.Locator;
import grail.model.APropertyListenerSupport;
import grail.model.PropertyListenerSupport;
import util.annotations.EditablePropertyNames;
import util.annotations.ObserverRegisterer;
import util.annotations.ObserverTypes;
import util.annotations.PropertyNames;
import util.annotations.Tags;

@PropertyNames({"X", "Y"})
@EditablePropertyNames({"X", "Y"})
@Tags({"Locatable"})
public abstract class BasicLocator implements Locator{
	protected int x,y;
	protected PropertyListenerSupport propertyListenerSupport = 
	         new APropertyListenerSupport();

	
	public BasicLocator() {
		this.x = 0;
		this.y = 0;
	}
	
	public BasicLocator(int x, int y) {
		this.x = x;
		this.y = y;
	}

	
	public int getX() {
		return this.x;
	}

	
	public void setX(int newX) {
		int oldVal = this.x;
		this.x = newX;
		if (propertyListenerSupport != null) {
			propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this, "X", oldVal,this.x));
		}
		
	}

	
	public int getY() {
		return y;
	}

	
	public void setY(int newY) {
		int oldVal = this.y;
		this.y = newY;
		if (propertyListenerSupport != null) {
			propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this, "Y", oldVal,this.y));
		}
		
	}

	@ObserverRegisterer(ObserverTypes.PROPERTY_LISTENER)
	public void addPropertyChangeListener(PropertyChangeListener arg0) {
		this.propertyListenerSupport.addElement(arg0);
		
	}	

}
//END OF FILE
//START OF FILE: src/grail/draw/objects/basicmutableshape.java
package grail.draw.objects;

import java.beans.PropertyChangeEvent;

import grail.draw.interfaces.MutableShape;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;

@PropertyNames({"X", "Y", "Height", "Width"})
@EditablePropertyNames({"X", "Y", "Height", "Width"})
public abstract class BasicMutableShape extends BasicShape implements MutableShape{

	public BasicMutableShape() {
		super();
	}
	
	public BasicMutableShape(int x, int y) {
		super(x,y);
	}

	
	public void setHeight(int newHeight) {
		int oldVal = this.height;
		this.height = newHeight;
		if (this.propertyListenerSupport != null) {
			this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this, "Height", oldVal, this.height));
		}
		
		
	}

	
	public void setWidth(int newWidth) {
		int oldVal = this.height;
		this.width = newWidth;
		if (this.propertyListenerSupport != null){
		this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this, "Width", oldVal, this.width));
		}
	}

}
//END OF FILE
//START OF FILE: src/grail/draw/objects/basicovalshape.java
package grail.draw.objects;

import java.awt.Color;

import grail.draw.interfaces.OvalShape;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;


@StructurePattern(StructurePatternNames.OVAL_PATTERN)
@PropertyNames({"X", "Y", "Width", "Height", "Color", "Filled"})
@EditablePropertyNames({"X", "Y", "Width", "Height", "Color", "Filled"})
public class BasicOvalShape extends BasicColorMutableShape implements OvalShape{
	
	public BasicOvalShape() {
		super();
		final int defaultValue = 100;
		this.x = defaultValue;
		this.y = defaultValue;
		this.height = defaultValue;
		this.width = defaultValue;
		this.color = Color.BLACK;
		this.filled = true;
	}

}
//END OF FILE
//START OF FILE: src/grail/draw/objects/basicrectangle.java
package grail.draw.objects;

import grail.draw.interfaces.Rectangle;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@StructurePattern(StructurePatternNames.RECTANGLE_PATTERN)
@PropertyNames({"X", "Y", "Height", "Width"})
@EditablePropertyNames({"X", "Y", "Height", "Width"})
@Tags({"Locatable"})
public class BasicRectangle extends BasicColorMutableShape implements Rectangle{

	public BasicRectangle() {
		super();
		final int defaultWidthAndHeight = 100;
		this.height = defaultWidthAndHeight;
		this.width = defaultWidthAndHeight;
	}
	
	public BasicRectangle(int width, int height) {
		super();
		this.width = width;
		this.height = height;
		
	}


}
//END OF FILE
//START OF FILE: src/grail/draw/objects/basicshape.java
package grail.draw.objects;

import grail.draw.interfaces.Shape;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.Tags;

@PropertyNames({"X", "Y", "Height", "Width"})
@EditablePropertyNames({"X", "Y"})
@Tags({"BoundedShape"})
public abstract class BasicShape extends BasicLocator implements Shape{
	protected int height, width;
	
	public BasicShape() {
		super();
	}
	
	public BasicShape(int x, int y) {
		super(x,y);
	}


	
	public int getHeight() {
		return height;
	}

	
	public int getWidth() {
		return width;
	}

}
//END OF FILE
//START OF FILE: src/grail/draw/objects/basicstringshape.java
package grail.draw.objects;

import java.awt.Color;
import java.beans.PropertyChangeEvent;

import grail.draw.interfaces.StringShape;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.STRING_PATTERN)
@PropertyNames({"X", "Y", "Text", "TextColor"})
@EditablePropertyNames({"X", "Y", "Text", "TextColor"})
public class BasicStringShape extends BasicLocator implements StringShape{
	String text;
	private Color textColor;
	
	public BasicStringShape() {
		this("Default",0,0);
		
	}
	
	public BasicStringShape(String text) {
		this(text,0,0);
	}
	
	public BasicStringShape(String text, int xPos, int yPos) {
		super();
		this.x = xPos;
		this.y = yPos;
		this.text = text;
		this.textColor = Color.black;
	}

	@Override
	public String getText() {
		return text;
	}

	@Override
	public void setText(String text) {
		String oldText = this.text;
		this.text = text;
		if (this.propertyListenerSupport != null) {
			this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this, "Text", oldText,this.text));
		}
	}
	

	@Override
	public Color getTextColor() {
		return this.textColor;
	}

	@Override
	public void setTextColor(Color newColor) {
		Color oldColor = this.textColor;
		this.textColor = newColor;
		if (this.propertyListenerSupport != null) {
			this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this, "TextColor", oldColor,this.textColor));
		}
		
	}


}
//END OF FILE
//START OF FILE: src/grail/draw/objects/linerotatingshape.java
package grail.draw.objects;

import java.beans.PropertyChangeEvent;

import grail.draw.interfaces.RotatingShape;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"RotatingLine"})
@StructurePattern(StructurePatternNames.LINE_PATTERN)
@PropertyNames({"X", "Y", "Height", "Width","Angle", "Radius" ,"Color", "Filled"})
@EditablePropertyNames({"X", "Y","Angle", "Radius","Color", "Filled"})
public class LineRotatingShape extends BasicColoredShape implements RotatingShape{
	private double radius, angle;

	public LineRotatingShape() {
	this(0,0,0,0);
	}
	
	public LineRotatingShape(int x, int y, double radius, double angle) {
		super();
		this.x = x;
		this.y = y;
		setRadius(radius);
		setAngle(angle);
	}


	
	public void setRadius(double val) {
		int oldHeight = this.height;
		int oldWidth = this.width;
		this.radius = val;
		double tempHeight =  this.radius * Math.sin(this.angle);
		this.height = (int) tempHeight;
		double tempWidth = this.radius * Math.cos(this.angle);
		this.width = (int) tempWidth;
		if (this.propertyListenerSupport != null) {
			this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this,"Height", oldHeight, this.height));
			this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this,"Width", oldWidth, this.width));
		}
		
	}

	
	public void setAngle(double val) {
		int oldHeight = this.height;
		int oldWidth = this.width;
		this.angle = val;
		double tempHeight =  this.radius * Math.sin(this.angle);
		this.height = (int) tempHeight;
		double tempWidth = this.radius * Math.cos(this.angle);
		this.width = (int) tempWidth;
		
		if (this.propertyListenerSupport != null) {
			this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this,"Height", oldHeight, this.height));
			this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this,"Width", oldWidth, this.width));
		}
		
	}

	@Tags({"rotate"})
	public void rotate(int units) {
		final double secondsInAMinute = 60;
		final double fullRotation = Math.PI * 2;
		final double clockUnit = fullRotation/secondsInAMinute;
		double distanceToRotate = units * clockUnit;
		double angleToSet = this.angle + distanceToRotate;
		setAngle(angleToSet);
	}

	
	public double getRadius() {
		return this.radius;
	}
	
	public double getAngle() {
		return this.angle;
	}

}
//END OF FILE
//START OF FILE: src/grail/draw/objects/platformovalshape.java
package grail.draw.objects;

import java.awt.Color;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

import grail.avatar.Avatar;
import grail.draw.interfaces.OvalShape;
import grail.draw.interfaces.Platform;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"X", "Y", "Width", "Height", "Color", "Filled", "Platform", "Shadow"})
@EditablePropertyNames({"X", "Y", "Width", "Height", "Color", "Filled"})
public class PlatformOvalShape extends BasicOvalShape implements Platform{
	private OvalShape platform, shadow;
	
	public PlatformOvalShape() {
		this(0,0);
		
	}
	
	public PlatformOvalShape(int x, int y) {
		final int defaultWidth = 120;
		final int defaultHeight = 25;
		this.x = x;
		this.y = y;
		this.color = Color.BLACK;
		this.platform = new BasicOvalShape();
		this.shadow = new BasicOvalShape();
		this.platform.setColor(Color.DARK_GRAY);
		this.shadow.setColor(Color.lightGray);
		this.width = defaultWidth;
		this.height = defaultHeight;
		buildPlatform(this.width, this.height);
	}

	
	public void setHeight(int newVal) {
		int oldHeight = this.height;
		this.height = newVal;
		buildPlatform(this.width,this.height);
		if (this.propertyListenerSupport != null){
		this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this, "Height", oldHeight, this.height));
		}
	}

	
	public void setWidth(int newVal) {
		int oldWidth = this.width;
		this.width = newVal;
		buildPlatform(this.width,this.height);
		if (this.propertyListenerSupport != null){
		this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this, "Width", oldWidth, this.width));
		}
	}


	
	public void setX(int x) {
		int oldX = this.x;
		this.x = x;
		setLocation(this.x,this.y);
		if (this.propertyListenerSupport != null){
		this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this, "X", oldX, this.x));
		}
	}
	
	public void setY(int y) {
		int oldY = this.y;
		this.y = y;
		setLocation(this.x,this.y);
		if (this.propertyListenerSupport != null){
		this.propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this, "Y", oldY, this.y));
		}
	}

	
	private void buildPlatform(int width, int height) {
		final int platformHeight = height; //25
		final int platformWidth = width; //100
		final double scaleFactor = .2;
		final double halfValue = 2;
		final int shadowHeight = (int)((height * scaleFactor) + height);
		final int shadowWidth =(int) ((width * scaleFactor) +  width);
		this.platform.setX(x);
		this.platform.setY(y);
		this.platform.setHeight(platformHeight);
		this.platform.setWidth(platformWidth);
		
		final int shadowOffX = (int)((width* scaleFactor)/halfValue);
		final int shadowOffY = (int)((height * scaleFactor)/halfValue);
		this.shadow.setX(x - shadowOffX);
		this.shadow.setY(y - shadowOffY);
		this.shadow.setHeight(shadowHeight);
		this.shadow.setWidth(shadowWidth);
		
	}
	
	public void move(int x, int y) {
		this.platform.setX(this.platform.getX() + x);
		this.platform.setY(this.platform.getY() + y);
		this.shadow.setX(this.shadow.getX() + x);
		this.shadow.setY(this.shadow.getY()  + y);
		this.x = this.x + x;
		this.y = this.y + y;
	}

	
	public void setLocation(int x, int y) {
		int xChange = x - this.x;
		int yChange = y - this.y;
		move(xChange, yChange);	
	}

	
	public OvalShape getShadow() {
		return this.shadow;
	}
	
	
	public OvalShape getPlatform() {
		return this.platform;
	}

	
	public int getAvatarX(Avatar aAvatar) {
		return this.x + Math.abs(this.width/2) - Math.abs(aAvatar.getHead().getWidth()/2);
	}

	
	public int getAvatarY(Avatar aAvatar) {
		return this.y - aAvatar.getHeight();
	}
	
	public static void addListenersToSubshapes(Platform shape, PropertyChangeListener listener) {
		shape.getPlatform().addPropertyChangeListener(listener);
		shape.getShadow().addPropertyChangeListener(listener);
	}

}
//END OF FILE
//START OF FILE: src/grail/exceptions/parsingexception.java
package grail.exceptions;

import util.annotations.Tags;

@SuppressWarnings("serial")
@Tags({"ParsingException"})
public class ParsingException extends Exception {

	public ParsingException(String message) {
		super(message);
	}


}
//END OF FILE
//START OF FILE: src/grail/exceptions/scanningexception.java
package grail.exceptions;

import util.annotations.Tags;

@SuppressWarnings("serial")
@Tags({"ScanningException"})
public class ScanningException extends Exception {

	public ScanningException(String message) {
		super(message);
	}

}
//END OF FILE
//START OF FILE: src/grail/factories/personalizedswingtextfieldfactory.java
package grail.factories;

import java.awt.Color;

import javax.swing.JTextField;

import bus.uigen.widgets.TextFieldFactory;
import bus.uigen.widgets.swing.SwingTextFieldFactory;

public class PersonalizedSwingTextFieldFactory extends SwingTextFieldFactory implements TextFieldFactory {
	
	@Override
	protected JTextField createJTextField(String aText) {
		JTextField toReturn = new JTextField(aText);
		toReturn.setBackground(Color.CYAN);
		toReturn.setForeground(Color.RED);
		return toReturn;
	} 
	
	
}
//END OF FILE
//START OF FILE: src/grail/factories/singletonscreator.java
package grail.factories;

import grail.avatar.Avatar;
import grail.commander.BasicCommandInterpreter;
import grail.commander.CommandInterpreter;
import grail.helpers.AScannerBean;
import grail.helpers.BasicCommandParser;
import grail.helpers.BasicTable;
import grail.helpers.BroadcastingClearanceManager;
import grail.helpers.ClearanceManager;
import grail.helpers.CommandParser;
import grail.helpers.Table;
import grail.interfaces.ScannerBean;
import grail.scene.BasicBridgeScene;
import grail.scene.BridgeScene;
import util.annotations.Tags;

@Tags({"SingletonsCreator"})
public class SingletonsCreator {
	private static ScannerBean scanner;
	private static CommandParser parser;
	private static BridgeScene scene;
	private static Table<String,Avatar> avatarList;
	private static CommandInterpreter commander;
	private static ClearanceManager manager;
	
	public SingletonsCreator() {
	}
	
	@Tags({"scannerFactoryMethod"})
	public static ScannerBean scannerFactoryMethod(){
		if (scanner == null) {
			scanner = new AScannerBean();
			return scanner;
		} else {
			return scanner;
		}

	}
	
	@Tags({"parserFactoryMethod"})
	public static CommandParser parserFactoryMethod(){
		if (parser == null) {
			parser = new BasicCommandParser();
			return parser;
		} else {
			return parser;
		}
		
	}
	
	@Tags({"bridgeSceneFactoryMethod"})
	public static BridgeScene bridgeSceneFactoryMethod(){
		if (scene == null) {
			scene = new BasicBridgeScene();
			return scene;
		} else {
			return scene;
		}
	}
	
	
	@Tags({"avatarTableFactoryMethod"})
	public static Table<String,Avatar> avatarTableFactoryMethod() {
		if (avatarList == null) {
			avatarList = new BasicTable<String,Avatar>();
			return avatarList;
		} else {
			return avatarList;
		}
	}
	
	@Tags({"commandInterpreterFactoryMethod"})
	public static CommandInterpreter commandInterpreterFactoryMethod() {
		if (commander == null) {
			commander = new BasicCommandInterpreter();
			return commander;
		} else {
			return commander;
		}
	}
	
	
	@Tags({"broadcastingClearnaceManagerMethod"})
	public static ClearanceManager broadcastingClearnaceManagerMethod() {
		if (manager == null) {
			manager = new BroadcastingClearanceManager();
			return manager;
		} else {
			return manager;
		}
	}
	
	static {
		scanner = new AScannerBean();
		avatarList = new BasicTable<String,Avatar>();
		scene = new BasicBridgeScene();
		manager = new BroadcastingClearanceManager();
		parser = new BasicCommandParser();
		commander = new BasicCommandInterpreter();
	}
}
//END OF FILE
//START OF FILE: src/grail/helpers/ascannerbean.java
package grail.helpers;

import util.annotations.ComponentWidth;
import util.annotations.EditablePropertyNames;
import util.annotations.ObserverRegisterer;
import util.annotations.ObserverTypes;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern; 
import util.annotations.StructurePatternNames; 
import util.annotations.Tags;
import grail.interfaces.WordToken;
import grail.model.APropertyListenerSupport;
import grail.model.PropertyListenerSupport;
import grail.tokens.EndStoreToken;
import grail.tokens.MinusStoreToken;
import grail.tokens.NumberStoreToken;
import grail.tokens.PlusStoreToken;
import grail.tokens.QuotedStoreToken;
import grail.tokens.StartStoreToken;
import grail.tokens.WordStoreToken;
import grail.interfaces.NumberToken;
import grail.interfaces.StoreToken;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

import grail.command.ApproachCommandToken;
import grail.command.CallCommandToken;
import grail.command.DefineCommandToken;
import grail.command.FailCommandToken;
import grail.command.MoveCommandToken;
import grail.command.PassCommandToken;
import grail.command.PrintStoredCommandToken;
import grail.command.ProceedAllCommandToken;
import grail.command.RedoCommandToken;
import grail.command.RepeatCommandToken;
import grail.command.RotateLeftArmCommandToken;
import grail.command.RotateRightArmCommandToken;
import grail.command.SayCommandToken;
import grail.command.SleepCommandToken;
import grail.command.ThreadCommandToken;
import grail.command.UndoCommandToken;
import grail.command.WaitCommandToken;
import grail.exceptions.ScanningException;
import grail.interfaces.ScannerBean;
import grail.interfaces.MutableIterator;

@Tags({"ScannerBean"}) 
@StructurePattern(StructurePatternNames.BEAN_PATTERN) 
@PropertyNames({"ScannedString", "Errors" , "Tokens", "TokenList"}) 
@EditablePropertyNames({"ScannedString"})

public class AScannerBean implements ScannerBean {
	private String scannedString = ""; 
	private StoreToken[] largeTokenArray;
	private StoreToken[] smallTokenArray;
	private int arrayPosition = 0;
	private int errorPosition = 0;
	private String[] errorString;
	private TokenHistory tokenList;
	private static final int COMPONENT_WIDTH = 600;
	protected PropertyListenerSupport propertyListenerSupport = new APropertyListenerSupport();
	private String errorsAsString;
	
	public AScannerBean() {
		//fix null values in arrays
		largeTokenArray = new StoreToken[0];
		smallTokenArray = new StoreToken[0];
		tokenList = new ATokenHistory();
		errorString = new String[1];
		String defaultError = "No Errors Found!";
		errorString[0] = defaultError;
		errorsAsString = "";
	}
	
	public void setScannedString(String input) throws ScanningException{
		//initial values
		scannedString = input;
		arrayPosition = 0;
		errorPosition = 0;
		largeTokenArray = new StoreToken[input.length()];
		this.errorString = new String[input.length()];
		this.errorsAsString = "Scanning returned the following errors:  \n";
		boolean errorsDetected = false;
		//populate array
		MutableIterator scan = new QuoteMutableIterator(input);
		while (scan.hasNext()) {
			
			String currentToken = scan.next();
            try {
            	StoreToken toAddToArray = getStoreToken(currentToken);
            	StoreToken toAddToHistory = getStoreToken(currentToken);
            	largeTokenArray[this.arrayPosition] = toAddToArray;
            	this.tokenList.add(toAddToHistory);
            	arrayPosition++;
            } catch (ScanningException se){
            	errorsDetected = true;
            	this.errorString[errorPosition] = se.getLocalizedMessage();
            	this.errorsAsString = this.errorsAsString + se.getLocalizedMessage() + "\n";
            	errorPosition++;
            }
		}
		
		smallTokenArray = parseStoreTokenArray(largeTokenArray);
		this.errorString = parseStringArray(this.errorString);
		
		if (propertyListenerSupport != null) {
			propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this, "ScannedString", null, this.scannedString));
			propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this, "Errors", null, this.errorString));
			propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this, "Tokens", null, this.smallTokenArray));
			propertyListenerSupport.notifyAllListeners(new PropertyChangeEvent(this, "TokenList", null, this.tokenList));

		}
		
		if (errorsDetected) {
			throw new ScanningException(this.errorsAsString);
		}
		
	}
	
	@ComponentWidth (COMPONENT_WIDTH)
	public String getScannedString() {
		return scannedString;
	}
	
	public StoreToken[] getTokens() {
		return this.smallTokenArray;
	}
	
	public String[] getErrors() {
		return this.errorString;
	}
	
	
	private StoreToken[] parseStoreTokenArray(StoreToken[] largeArray) {
		int index = 0;
		int smallSize = getParsedArraySize(largeArray);
		StoreToken[] smallArray = new StoreToken[smallSize];
		while (index < smallSize) {
			smallArray[index] = largeArray[index];
			index++;
		}
		
		return smallArray;
	}
	
	private String[] parseStringArray(String[] largeArray) {
		int index = 0;
		int smallSize = getParsedArraySize(largeArray);
		String[] smallArray = new String[smallSize];
		while (index < smallSize) {
			smallArray[index] = largeArray[index];
			index++;
		}
		
		return smallArray;
	}
	
	private int getParsedArraySize(StoreToken[] input) {
		int currentSize = 0;
		for (int i = 0; i < input.length; i++) {
			if (!(input[i] == null)) {
				currentSize++;
			}
		}
		
		return currentSize;
	}
	
	private int getParsedArraySize(String[] input) {
		int currentSize = 0;
		for (int i = 0; i < input.length; i++) {
			if (!(input[i] == null)) {
				currentSize++;
			}
		}
		
		return currentSize;
	}
	
	private StoreToken getStoreToken(String token) throws ScanningException {
		int currentTokenLength = token.length();
		char currentChar = token.charAt(0);
		if ((currentChar == '+') && currentTokenLength == 1) {
			StoreToken output = new PlusStoreToken(token);
			return output;
			
		} else if (currentChar == '-' && currentTokenLength == 1) {
			StoreToken output = new MinusStoreToken(token);
			return output;
		} else if (currentChar == '"') {
			if ((token.charAt(currentTokenLength - 1) == '"') && currentTokenLength >1){
				token = processFinalToken(token);
				StoreToken output = new QuotedStoreToken(token);
				return output;
				
			} else {
				//errorString[errorPosition] = token + " was missing an end quote. Stored as a single word quote.";
				token = removeStartQuote(token);
				StoreToken output = new QuotedStoreToken(token);
				return output;
				
			}
		} else if (isNumber(token)) {
			NumberToken numClass = new NumberStoreToken(token);
			return numClass;
			
		} else if (isWord(token)) {
			WordToken input = generateWordClass(token);
			return input;
			
		} else if (currentChar == '{' && currentTokenLength == 1) {
			StoreToken output = new StartStoreToken(token);
			return output;
			
		}else if (currentChar == '}' && currentTokenLength == 1) {
			StoreToken output = new EndStoreToken(token);
			return output;
			
		}else {
			throw new ScanningException("The string entered: " + token + " is not an acceptable token! Token Ignored.");
		}
	}

	public TokenHistory getTokenList() {
		return this.tokenList;
	}
	
	private WordToken generateWordClass(String input) {
		WordToken ret;
		if ("move".equalsIgnoreCase(input)) {
			ret = new MoveCommandToken(input);
		} else if ("say".equalsIgnoreCase(input)){
			ret = new SayCommandToken(input);
		} else if ("rotateleftarm".equalsIgnoreCase(input)){
			ret = new RotateLeftArmCommandToken(input);
		} else if ("rotaterightarm".equalsIgnoreCase(input)){
			ret = new RotateRightArmCommandToken(input);
		} else if ("repeat".equalsIgnoreCase(input)){
			ret = new RepeatCommandToken(input);
		} else if ("define".equalsIgnoreCase(input)){
			ret = new DefineCommandToken(input);
		} else if ("call".equalsIgnoreCase(input)){
			ret = new CallCommandToken(input);
		} else if ("thread".equalsIgnoreCase(input)){
			ret = new ThreadCommandToken(input);
		} else if ("wait".equalsIgnoreCase(input)){
			ret = new WaitCommandToken(input);
		} else if ("proceedall".equalsIgnoreCase(input)){
			ret = new ProceedAllCommandToken(input);
		} else if ("sleep".equalsIgnoreCase(input)){
			ret = new SleepCommandToken(input);
		} else if ("undo".equalsIgnoreCase(input)){
			ret = new UndoCommandToken(input);
		} else if ("redo".equalsIgnoreCase(input)){
			ret = new RedoCommandToken(input);
		} else if ("approach".equalsIgnoreCase(input)) {
			ret = new ApproachCommandToken(input);
		} else if ("pass".equalsIgnoreCase(input)) {
			ret = new PassCommandToken(input);
		} else if ("fail".equalsIgnoreCase(input)) {
			ret = new FailCommandToken(input);
		}else if ( "print".equalsIgnoreCase(input)) {
			ret = new PrintStoredCommandToken(input);
		} else {
			ret = new WordStoreToken(input);
		}
		return ret;
	}
	
/*	private static boolean isLetter(char inputChar) {
		return ((inputChar >= 'a' && inputChar <= 'z') || (inputChar >= 'A' && inputChar <= 'Z'));
	} */
	
	private boolean checkForStartQuote(String token) {
		if (token.length() > 0 && token.charAt(0) == '"') {
			return true;
		} 
		return false;
		
	}
	
	private boolean checkForEndQuote(String token) {
		if (token.length() > 0  && token.charAt(token.length() - 1) == '"') {
			return true;
		}
		
		return false;
	}
	
	private String removeStartQuote(String token) {
		String returnString = "";
		int index = 0;
		while (index < token.length() - 1) {
			returnString = returnString + token.charAt(index + 1);
			index++;
		}
		
		return returnString;
	} 
	
	private boolean isWord(String token) {
		int index = 0;
		while (index < token.length()) {
			if (!Character.isLetter(token.charAt(index))) {
				return false;
			}
			index++;
		}
		
		return true;
	}
	
	private boolean isNumber(String token){
		int index = 0;
		while (index < token.length()) {
			if (!Character.isDigit(token.charAt(index))) {
				return false;
			}
			index++;
		}
		
		return true;
	}
	
	
	private String processFinalToken(String token) {
		String returnString = token;
		
		if (checkForStartQuote(token) && checkForEndQuote(token)) {
			returnString = returnString.substring(1, token.length() - 1);
		}
		
		return returnString;
	}
	
	

	@ObserverRegisterer(ObserverTypes.PROPERTY_LISTENER)
	public void addPropertyChangeListener(PropertyChangeListener arg0) {
		propertyListenerSupport.addElement(arg0);
		
	}
	
}
//END OF FILE
//START OF FILE: src/grail/helpers/atokenhistory.java
package grail.helpers;

import grail.interfaces.StoreToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"ClearableHistory"})
@StructurePattern(StructurePatternNames.LIST_PATTERN) 
@PropertyNames({}) 
@EditablePropertyNames({})
public class ATokenHistory implements TokenHistory {
	public static final int MAX_SIZE = 100;
	protected StoreToken[] contents = new StoreToken[MAX_SIZE];
	protected int size = 0;
	
	public ATokenHistory() {
	
	}

	public int size() {
		return size;
	}
	
	public StoreToken get(int index) {
		return contents[index];
	}

	protected boolean isFull() {
		return size == MAX_SIZE;

	}
	
	public void add(StoreToken element) {
		if (isFull()) {
			clear();
		}
		else {
			contents[size] = element;
			size++;
		}
	} 
	
	public String toString() {
		String retVal = "";
		for (int i = 0; i < size; i++) {
			String separator = (i == 0)?"":",";
			retVal += separator + contents[i];
		}		
		return super.toString() + ":The tokens stored are:" + retVal;
	}

	@Tags({"clear"})
	public void clear() {
		for(int i = 0; i < size; i++) {
			contents[i] = null;
		}
		size = 0;
	}
	

}
//END OF FILE
//START OF FILE: src/grail/helpers/basiccommandparser.java
package grail.helpers;

import grail.avatar.Avatar;
import grail.command.ApproachCommandToken;
import grail.command.CallCommandToken;
import grail.command.DefineCommandToken;
import grail.command.FailCommandToken;
import grail.command.MoveCommandToken;
import grail.command.PassCommandToken;
import grail.command.PrintStoredCommandToken;
import grail.command.ProceedAllCommandToken;
import grail.command.RedoCommandToken;
import grail.command.RepeatCommandToken;
import grail.command.RotateLeftArmCommandToken;
import grail.command.RotateRightArmCommandToken;
import grail.command.SayCommandToken;
import grail.command.SleepCommandToken;
import grail.command.ThreadCommandToken;
import grail.command.UndoCommandToken;
import grail.exceptions.ParsingException;
import grail.exceptions.ScanningException;
import grail.factories.SingletonsCreator;
import grail.interfaces.NumberToken;
import grail.interfaces.ScannerBean;
import grail.interfaces.StoreToken;
import grail.interfaces.UndoableRunnable;
import grail.runnables.ApproachCommand;
import grail.runnables.CallCommand;
import grail.runnables.CommandList;
import grail.runnables.DefaultCommand;
import grail.runnables.DefineCommand;
import grail.runnables.FailCommand;
import grail.runnables.MoveCommand;
import grail.runnables.PassCommand;
import grail.runnables.ProceedAllCommand;
import grail.runnables.RedoCommand;
import grail.runnables.RepeatCommand;
import grail.runnables.RotateLeftArmCommand;
import grail.runnables.RotateRightArmCommand;
import grail.runnables.RunnableList;
import grail.runnables.SayCommand;
import grail.runnables.SleepCommand;
import grail.runnables.ThreadCommand;
import grail.runnables.UndoCommand;
import grail.scene.BridgeScene;
import grail.tokens.EndStoreToken;
import grail.tokens.MinusStoreToken;
import grail.tokens.NumberStoreToken;
import grail.tokens.PlusStoreToken;
import grail.tokens.QuotedStoreToken;
import grail.tokens.StartStoreToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Parser"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"CommandText", "CommandObject","Errors"})
@EditablePropertyNames({"CommandText"})
public class BasicCommandParser implements CommandParser {
	private BridgeScene scene;
	private Table<String,Avatar> knightList;
	private ScannerBean scanner;
	private StoreToken[] tokenArray;
	private String errors;
	private int currentPosition;
	private Runnable returnCommand;
	private Table<String,Runnable> commandList;
	private ClearanceManager manager;
	private Runnable previousCommand;
	
	public BasicCommandParser(BridgeScene scene, ClearanceManager manager) {
		this.scene = scene;
		this.manager = manager;
		this.knightList = scene.getKnightList();
		this.commandList = new BasicTable<String,Runnable>();
		this.scanner = SingletonsCreator.scannerFactoryMethod();
		try {
			this.scanner.setScannedString("Default");
		} catch (ScanningException se) {
			//do nothing
		}
		this.tokenArray = this.scanner.getTokens();
		this.errors = "No Errors Found!";
		this.currentPosition = 0;
		this.returnCommand = new DefaultCommand();
		this.previousCommand = new DefaultCommand();
	}
	
	public BasicCommandParser(BridgeScene scene) {
		this (scene, SingletonsCreator.broadcastingClearnaceManagerMethod());
	}
	
	public BasicCommandParser() {
		this (SingletonsCreator.bridgeSceneFactoryMethod());
	}

	public void setCommandText(String text)  {
		this.errors = "";
		
		try {
			this.scanner.setScannedString(text);
		} catch (ScanningException se) {
			this.errors = this.errors + se.getLocalizedMessage();
		}
		
		this.tokenArray = this.scanner.getTokens();
		this.currentPosition = 0;
		
		this.errors = this.errors + "Parsing returned the following errors:";
		
		try {
			this.returnCommand = parseCommand();
			this.errors = this.errors + "\nCommand was parsed successfully! Note: Excess or error tokens ignored.";
		} catch (ParsingException pe) {
			this.errors = this.errors + pe.getLocalizedMessage();
			this.returnCommand = new DefaultCommand();
		} 
	}


	public Runnable getCommandObject() {
		return this.returnCommand;
	}

	
	public String getErrors() {
		return this.errors;
		
	}

	@Tags({"parseCommand"})
	public Runnable parseCommand() throws ParsingException {
		Runnable returnCommand;
		StoreToken currentToken = (this.currentPosition < this.tokenArray.length)? this.tokenArray[this.currentPosition]:null;
		currentPosition++;
			if (currentToken instanceof SayCommandToken) {
				returnCommand = parseSay();
			} else if (currentToken instanceof MoveCommandToken) {
					returnCommand = parseMove();
					this.previousCommand = returnCommand;
			} else if (currentToken instanceof ApproachCommandToken) {
					returnCommand = parseApproach();
					this.previousCommand = returnCommand;
			} else if (currentToken instanceof PassCommandToken) {
					returnCommand = parsePass();
					this.previousCommand = returnCommand;
			} else if (currentToken instanceof FailCommandToken) {
					returnCommand = parseFail();
					this.previousCommand =  returnCommand;
			} else if (currentToken instanceof StartStoreToken) {
					returnCommand = parseCommandList();
					this.previousCommand = returnCommand;
			} else if (currentToken instanceof RepeatCommandToken) {
					returnCommand = parseRepeat();
					this.previousCommand = returnCommand;
			} else if (currentToken instanceof RotateLeftArmCommandToken) {
					returnCommand = parseLeftArm();
					this.previousCommand = returnCommand;
			} else if (currentToken instanceof RotateRightArmCommandToken) {
					returnCommand = parseRightArm();
					this.previousCommand = returnCommand;
			} else if (currentToken instanceof SleepCommandToken) {
					returnCommand = parseSleep();
					this.previousCommand = returnCommand;
			} else if (currentToken instanceof DefineCommandToken) {
					returnCommand = parseDefine();
					this.previousCommand = returnCommand;
			} else if (currentToken instanceof CallCommandToken) {
					returnCommand = parseCall();
					this.previousCommand = returnCommand;
			} else if (currentToken instanceof ThreadCommandToken) {
					returnCommand = parseThread();
					this.previousCommand = returnCommand;
			} else if (currentToken instanceof PrintStoredCommandToken) {
					returnCommand = parsePrint();
					this.previousCommand = returnCommand;
			} else if (currentToken instanceof ProceedAllCommandToken) {
					returnCommand = parseProceedAll();
					this.previousCommand = returnCommand;
			} else if (currentToken instanceof UndoCommandToken) {
					returnCommand = parseUndo();
			} else if (currentToken instanceof RedoCommandToken) {
					returnCommand = parseRedo();
			} else {	
				throw new ParsingException("\nA Command Token was not found when parseCommand() was run. No command was executed!");
			}
			return returnCommand;
	}

	@Tags({"parseSay"})
	public Runnable parseSay() throws ParsingException{
	    int remainderLength = tokenArray.length - currentPosition;
		
	    if (remainderLength >= 1  && tokenArray[currentPosition] instanceof QuotedStoreToken) {
			int returnPosition = currentPosition;
	    	currentPosition++;
			return new SayCommand(this.scene, tokenArray[returnPosition].getInput());
		} else {
			throw new ParsingException("\nError: Say command has syntax: say \"Quote\"");
		}
	}

	
	@Tags({"parseMove"})
	public Runnable parseMove() throws ParsingException{
		 Avatar toMove = (this.currentPosition < this.tokenArray.length && isAvatar(this.tokenArray[this.currentPosition]))? (Avatar) this.knightList.get(this.tokenArray[this.currentPosition].getInput().toLowerCase()):null;
		 if (toMove != null) {
			 currentPosition++;
			 int xAmount = 0;
			 int yAmount = 0;
			 xAmount = numberParser();
			 yAmount = numberParser();	 
			 return new MoveCommand(toMove, xAmount, yAmount);
		} else {
			 throw new ParsingException("\nAvatar token was not found. Please use syntax: move <Avatar> <Number> <Number>");
		}
		 
	}

	@Tags({"parseApproach"})
	public Runnable parseApproach() throws ParsingException{
		int remainderLength = tokenArray.length - currentPosition;
		
	    if (remainderLength >= 1  && isAvatar(tokenArray[currentPosition])) {
			int returnPosition = currentPosition;
	    	currentPosition++;
			return new ApproachCommand(this.scene, (Avatar) (this.knightList.get(tokenArray[returnPosition].getInput().toLowerCase())));
		} else {
			 throw new ParsingException("\nApproach command has syntax: approach knight");

		}
	}

	
	@Tags({"parsePass"})
	public Runnable parsePass() {
		return new PassCommand(this.scene);
	}

	@Tags({"parseFail"})
	public Runnable parseFail() {
		return new FailCommand(this.scene);
	}

	@Tags({"parseCommandList"})
	public Runnable parseCommandList() throws ParsingException {
		RunnableList returnList = new CommandList();
		int artificialEnd = getMatchingEndQuote();
		while (this.currentPosition < artificialEnd) {
			returnList.add(parseCommand());
		}
		
		this.currentPosition = artificialEnd + 1;
		return (CommandList) returnList;
	}

	@Tags({"parseRepeat"})
	public Runnable parseRepeat() throws ParsingException {
		int numberOfRepeats = numberParser();
		Runnable commandToExecute = parseCommand();
		return new RepeatCommand(numberOfRepeats, commandToExecute);
		
	}
	
	@Tags({"numberParser"})
	public int numberParser() throws ParsingException{
		StoreToken firstToken = (this.currentPosition < this.tokenArray.length)? this.tokenArray[this.currentPosition]:null;
		if (isNumber(firstToken)) {
			this.currentPosition++;
			return ((NumberStoreToken) firstToken).getValue();
		} else if (isSign(firstToken) && this.currentPosition + 1 < this.tokenArray.length && isNumber(this.tokenArray[this.currentPosition + 1]) ) {
			int signNumber = (firstToken instanceof PlusStoreToken)? 1:-1;
			currentPosition++;
			StoreToken secondToken = this.tokenArray[this.currentPosition];
			currentPosition++;
			return signNumber * ((NumberStoreToken) secondToken).getValue();
		 } else {
			throw new ParsingException("\nA number was not found in the proper format. Please Check your input.");
		 }
	}


	
		
	private boolean isAvatar(StoreToken input) {
		 	return (this.knightList.contains(input.getInput().toLowerCase()));
		 
	}	
	
		
	private boolean isSign(StoreToken input) {
		return (input instanceof PlusStoreToken || input instanceof MinusStoreToken);
	}
	
	private boolean isNumber(StoreToken input) {
		return input instanceof NumberToken;
	}
	
	private int getMatchingEndQuote() throws ParsingException{
		int counter = 1;
		int endPosition = this.currentPosition;
		try {
			while (counter > 0) {
				StoreToken currentToken = this.tokenArray[endPosition];
				if ( currentToken instanceof StartStoreToken) {
					counter++;
				} else if ( currentToken instanceof EndStoreToken) {
					counter--;
				}
				endPosition++;
			} 
		} catch (StackOverflowError e) {
			throw new ParsingException("\nOverflow: An End Quote was not found in command. Check for }");
		} catch (Exception e) {
			throw new ParsingException("\nException: An End Quote was not found in command. Check for }");
		}
		return endPosition - 1;
	}

	@Tags({"parseLeftArm"})
	public Runnable parseLeftArm() throws ParsingException{
		 Avatar toMove = (this.currentPosition < this.tokenArray.length && isAvatar(this.tokenArray[this.currentPosition]))? (Avatar) this.knightList.get(this.tokenArray[this.currentPosition].getInput().toLowerCase()):null;
		 if (toMove != null) {
			 currentPosition++;
			 int rotateAmount = numberParser();
			 return new RotateLeftArmCommand(toMove, rotateAmount);
		} else {
			throw new ParsingException("\nAvatar token was not found. Please use syntax: rotateLeftArm <Avatar> <Number>");

		}
		
	}

	@Tags({"parseRightArm"})
	public Runnable parseRightArm() throws ParsingException{
		Avatar toMove = (this.currentPosition < this.tokenArray.length && isAvatar(this.tokenArray[this.currentPosition]))? (Avatar) this.knightList.get(this.tokenArray[this.currentPosition].getInput().toLowerCase()):null;
		 if (toMove != null) {
			 currentPosition++;
			 int rotateAmount = numberParser();
			 return new RotateRightArmCommand(toMove, rotateAmount);
		} else {
			throw new ParsingException("\nAvatar token was not found. Please use syntax: rotateRighttArm <Avatar> <Number>");

		}
	}

	@Tags({"parseSleep"})
	public Runnable parseSleep() throws ParsingException {
		long amountToSleep = (long) numberParser();
		return new SleepCommand(amountToSleep);
	}

	@Tags({"parseDefine"})
	public Runnable parseDefine() throws ParsingException {
		String commandName = (this.currentPosition < this.tokenArray.length)? this.tokenArray[this.currentPosition].getInput():null;
		if (commandName != null) {
			currentPosition++;
		} else {
			throw new ParsingException("\nDefine is missing a name for command. Use syntax: define <Word> <Command>");
		}
		
		
		Runnable command = parseCommand();
		
		if (command != null) {
			return new DefineCommand(commandName, command, this.commandList);
		} else {
			throw new ParsingException("\nDefine did not find a command. Use Syntax: define <Word> <Command>");
		}
	}

	@Tags({"parseCall"})
	public Runnable parseCall() throws ParsingException {
		String commandName = (this.currentPosition < this.tokenArray.length && this.commandList.contains(this.tokenArray[this.currentPosition].getInput()))? this.tokenArray[this.currentPosition].getInput():null;
		if (commandName != null) {
			currentPosition++;
			return new CallCommand(commandName, this.commandList);
		} else {
			throw new ParsingException("\nCall did not find a command with that name or syntax was not: call <Name>. Use Define to add commands. Use Print to view stored commands");
		}
	}

	@Tags({"parseThread"})
	public Runnable parseThread() throws ParsingException{
		String commandName = (this.currentPosition < this.tokenArray.length && this.commandList.contains(this.tokenArray[this.currentPosition].getInput()))? this.tokenArray[this.currentPosition].getInput():null;
		if (commandName != null) {
			currentPosition++;
			return new ThreadCommand(commandName, this.commandList);
		} else {
			throw new ParsingException("\nThread did not find a command with that name or syntax was not: Thread <Name>. Use Define to add commands. Use Print to view stored commands");
		}
	}
	
	@Tags({"parseProceedAll"})
	public Runnable parseProceedAll() {
		return new ProceedAllCommand(this.manager);
	}
	
	@Tags({"parseUndo"})
	public Runnable parseUndo() throws ParsingException {
		try {
			return new UndoCommand(((UndoableRunnable) this.previousCommand));
		} catch (ClassCastException ce) {
			throw new ParsingException("\nThe previous command can not be undone.");
		}
	}
	
	@Tags({"parseRedo"})
	public Runnable parseRedo() throws ParsingException {
		try {
			return new RedoCommand(((UndoableRunnable) this.previousCommand));
		} catch (ClassCastException ce) {
			throw new ParsingException("\nThe previous command can not be redone.");
		} 
	}
	
	@Tags({"parsePrint"})
	public Runnable parsePrint() {
		this.errors = "The following commands are available to be run:\n";
		this.errors = this.errors + this.commandList.keyList();
		return new DefaultCommand();
	}
	
}
//END OF FILE
//START OF FILE: src/grail/helpers/basictable.java
package grail.helpers;

import java.util.ArrayList;
import java.util.List;

import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Table", "generic"})
@StructurePattern(StructurePatternNames.MAP_PATTERN)
public class BasicTable<KeyType, ValueType> implements Table<KeyType, ValueType>{
	protected List<ValueType> valueColumn;
	protected List<KeyType> keyColumn;
	
	public BasicTable() {
		this.valueColumn = new ArrayList<ValueType>();
		this.keyColumn = new ArrayList<KeyType>();
		
	}
	
	public void put(KeyType key, ValueType val) {
		int spotToCheck = 0;
		if (this.keyColumn.contains(key) && !(key == null || val == null)) {
			while (spotToCheck < this.keyColumn.size()) {
				Object currentKey = this.keyColumn.get(spotToCheck);
				if (currentKey.equals(key)) {
					this.valueColumn.set(spotToCheck, val);
				}
				spotToCheck++;
	
			}
		} else if (!(key == null || val == null)){
			this.keyColumn.add(key);
			this.valueColumn.add(val);
		} else {
			//do nothing
		}
		
	}

	
	public ValueType get(KeyType key) {
		int spotToCheck = 0;
		while (spotToCheck < this.keyColumn.size()) {
			Object currentKey = this.keyColumn.get(spotToCheck);
			if (currentKey.equals(key)) {
				return this.valueColumn.get(spotToCheck);
			}
			spotToCheck++;
		}
		return null;
	}

	public void print() {
		int startingPoint = 0;
		while (startingPoint < this.valueColumn.size()) {
			String toPrint = "Key: " + this.keyColumn.get(startingPoint).toString() + " Value: " + this.valueColumn.get(startingPoint).toString();
			System.out.println(toPrint);
			startingPoint++;
		}
		
	}

	public boolean contains(KeyType key) {
		int spotToCheck = 0;
		while (spotToCheck < this.keyColumn.size()) {
			Object currentKey = this.keyColumn.get(spotToCheck);
			if (currentKey.equals(key)) {
				return true;
			}
			spotToCheck++;
		}
		return false;
	}

	public String keyList() {
		String toReturn = "";
		for (int i = 0; i < this.keyColumn.size(); i++) {
			toReturn = toReturn + this.keyColumn.get(i).toString() + "\n";
		}
		return toReturn;
	}


	

}
//END OF FILE
//START OF FILE: src/grail/helpers/broadcastingclearancemanager.java
package grail.helpers;

import grail.helpers.ClearanceManager;
import util.annotations.ComponentWidth;
import util.annotations.Row;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.NO_PATTERN)
public class BroadcastingClearanceManager implements ClearanceManager {
	private final int componentWidth = 100;
	
	public BroadcastingClearanceManager() {
	}

    @Row(0)
    @ComponentWidth(componentWidth)
	public synchronized void proceed() {
		notify();
	}

    @Row(1)
    @ComponentWidth(componentWidth)
	public synchronized void proceedAll() {
		notifyAll();
		
	}

	public synchronized void waitForProceed() {
		try {
			wait();
		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}

}
//END OF FILE
//START OF FILE: src/grail/helpers/clearancemanager.java
package grail.helpers;


public interface ClearanceManager {
	public void proceed();
	public void proceedAll();
	public void waitForProceed();
}
//END OF FILE
//START OF FILE: src/grail/helpers/commandparser.java
package grail.helpers;

import grail.exceptions.ParsingException;

public interface CommandParser {
	public void setCommandText(String text);
	public Runnable getCommandObject();
	public String getErrors();
	public Runnable parseCommand() throws ParsingException;
	public Runnable parseSay() throws ParsingException;
	public Runnable parseMove() throws ParsingException;
	public Runnable parseApproach() throws ParsingException;
	public Runnable parsePass();
	public Runnable parseFail();
	public Runnable parseCommandList() throws ParsingException;
	public Runnable parseRepeat() throws ParsingException;
	public int numberParser() throws ParsingException;
	public Runnable parseLeftArm() throws ParsingException;
	public Runnable parseRightArm() throws ParsingException;
	public Runnable parseSleep() throws ParsingException;
	public Runnable parseDefine() throws ParsingException;
	public Runnable parseCall() throws ParsingException;
	public Runnable parseThread() throws ParsingException;
	public Runnable parseProceedAll();
	public Runnable parsePrint();
}
//END OF FILE
//START OF FILE: src/grail/helpers/componentbuilder.java
package grail.helpers;

import java.awt.Color;
import grail.draw.interfaces.Rectangle;
import grail.draw.objects.BasicRectangle;
import grail.factories.SingletonsCreator;
import grail.paint.AObservablePainter;
import grail.paint.ObservablePainter;
import grail.scene.BridgeScene;
import grail.view.ABackgroundView;
import grail.view.AGorgeView;
import grail.view.APlatformView;
import grail.view.AnAvatarView;
import grail.view.AvatarView;
import grail.view.BackgroundView;
import grail.view.GorgeView;
import grail.view.PlatformView;

public class ComponentBuilder {
	
	public static ObservablePainter buildObservablePainterFromScene(BridgeScene scene, Color backgroundcolor) {
		final int frameWidth = 1600;
		final int frameHeight = 1000;
		
		ObservablePainter singleComponentModel = new AObservablePainter();
		
		Rectangle backgroundRectangle = new BasicRectangle();
		backgroundRectangle.setHeight(frameHeight);
		backgroundRectangle.setWidth(frameWidth);
		backgroundRectangle.setColor(backgroundcolor);
		
		//create views to go in ObservablePainter
		BackgroundView background = new ABackgroundView(backgroundRectangle, singleComponentModel);
		AvatarView arthurView = new AnAvatarView(scene.getArthur(), singleComponentModel);
		AvatarView galahadView = new AnAvatarView(scene.getGalahad(), singleComponentModel);
		AvatarView robinView = new AnAvatarView(scene.getRobin(), singleComponentModel);
		AvatarView lancelotView = new AnAvatarView(scene.getLancelot(), singleComponentModel);
		AvatarView guardView = new AnAvatarView(scene.getGuard(), singleComponentModel);
		PlatformView knightPlatformView = new APlatformView(scene.getKnightArea(), singleComponentModel);
		PlatformView guardPlatformView = new APlatformView(scene.getGuardArea(), singleComponentModel);
		GorgeView gorgeView = new AGorgeView(scene.getGorge(), singleComponentModel);
		
		//Add views to ObservablePainter
		
		singleComponentModel.addPaintListener(background);
		singleComponentModel.addPaintListener(knightPlatformView);
		singleComponentModel.addPaintListener(guardPlatformView);
		singleComponentModel.addPaintListener(gorgeView);
		singleComponentModel.addPaintListener(arthurView);
		singleComponentModel.addPaintListener(galahadView);
		singleComponentModel.addPaintListener(robinView);
		singleComponentModel.addPaintListener(lancelotView);
		singleComponentModel.addPaintListener(guardView);

		
		return singleComponentModel;
	}
	
	public static ObservablePainter buildObservablePainterFromScene(BridgeScene scene) {
		return buildObservablePainterFromScene(scene, Color.WHITE);
	} 
	
	public static ObservablePainter buildObservablePainterFromScene() {
		return buildObservablePainterFromScene(SingletonsCreator.bridgeSceneFactoryMethod());
	}

}
//END OF FILE
//START OF FILE: src/grail/helpers/quotemutableiterator.java
package grail.helpers;

import grail.interfaces.MutableIterator;

public class QuoteMutableIterator implements MutableIterator{
	private int currentIndexPosition = 0;
	private String inputString = "";
	
	
	public QuoteMutableIterator(String input) {
		inputString = input;
	}

	@Override
	public boolean hasNext() {
		char currentChar = 'a';
		
		//probes for another token. Returns false if it does not find one.
		int currentPosition = currentIndexPosition;
		int stringLength = inputString.length();
		if ((currentPosition < stringLength)) {
			currentChar = inputString.charAt(currentPosition);
		}	
		while ((currentChar == ' ') && currentPosition < stringLength) {
			currentPosition++;
			if ((currentPosition < stringLength)) {
				currentChar = inputString.charAt(currentPosition);
			} else {
				break;
			}
		}
		
		if (currentPosition < (stringLength)) {
			return true;
		} 
			return false;
	}

	@Override
	public String next() {
		String currentReturn = "";
		
		char currentChar = inputString.charAt(currentIndexPosition);
		if ((currentChar == ' ')){
			clearWhiteSpace();
			if (currentIndexPosition < inputString.length()){
				currentChar = inputString.charAt(currentIndexPosition);
			}
			if (currentChar == '"') {
				currentReturn = processQuote();
			} else {
				currentReturn = createNextToken(currentReturn, currentChar);
			}
		} else {
			if (currentIndexPosition < inputString.length()){
				currentChar = inputString.charAt(currentIndexPosition);
			}
			
			if (currentChar == '"') {
				currentReturn = processQuote();
			} else {
				currentReturn = createNextToken(currentReturn, currentChar);
			}

		}
		
		return currentReturn;
	}

	
	@Override
	public void setString(String input) {
		this.inputString = input;
		
	}

	@Override
	public void setCurrentPosition(int position) {
		currentIndexPosition = position;
		
	}

	@Override
	public int getCurrentPosition() {
		return currentIndexPosition;
	}

	@Override
	public String getString() {
		return inputString;
	}

	
	private void clearWhiteSpace() {
		char currentChar = 'a';
		int stringLength = inputString.length();
		if ((currentIndexPosition < stringLength)) {
			currentChar = inputString.charAt(currentIndexPosition);
		}	
		while ((currentChar == ' ') && currentIndexPosition < stringLength) {
			currentIndexPosition++;
			if (!(currentIndexPosition >= stringLength)) {
				currentChar = inputString.charAt(currentIndexPosition);
			} else {
				break;
			}
		}
	}
	
	private String createNextToken(String currentReturn, char currentChar) {
		int stringLength = inputString.length();
		while(!(currentChar == ' ') && currentIndexPosition < stringLength) {
			currentReturn = currentReturn + currentChar;
			currentIndexPosition++;
				if (currentIndexPosition < inputString.length()){
				currentChar = inputString.charAt(currentIndexPosition);
				}
		}
		
		return currentReturn;
	}
	
	private String processQuote() {
		String returnString = "";
		int tempIndex = currentIndexPosition;
		int tempIndexQuote = currentIndexPosition;
		String firstToken = "";
		char currentChar = inputString.charAt(tempIndex);
		returnString = returnString + currentChar;
		
		//makes the first token without a space in case one is not found.
		while(!(currentChar == ' ') && tempIndex < inputString.length()) {
			firstToken = firstToken + currentChar;
			tempIndex++;
				if (tempIndex < inputString.length()){
				currentChar = inputString.charAt(tempIndex);
				}
		}
		
		tempIndexQuote++;
		if ((tempIndexQuote < inputString.length())) {
			currentChar = inputString.charAt(tempIndexQuote);
		} else {
			currentChar = inputString.charAt(currentIndexPosition);
		}
		
		while(!(currentChar == '"') && tempIndexQuote < inputString.length()) {
			returnString = returnString + currentChar;
			tempIndexQuote++;
				if (tempIndexQuote < inputString.length()){
				currentChar = inputString.charAt(tempIndexQuote);
				}
		}
		
		if (currentChar == '"' && !(tempIndexQuote == inputString.length())) {
			returnString = returnString + "\"";
			tempIndexQuote++;
			currentIndexPosition = tempIndexQuote;
			return returnString;
		} else {
			currentIndexPosition = tempIndex;
			return firstToken;
		}
		
	}
}
//END OF FILE
//START OF FILE: src/grail/helpers/table.java
package grail.helpers;

import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Table", "generic"})
@StructurePattern(StructurePatternNames.MAP_PATTERN)
public interface Table<KeyType, ValueType> {
	public void put (KeyType key, ValueType val);
	public ValueType get (KeyType key);
	public void print();
	public boolean contains(KeyType key);
	public String keyList();
}
//END OF FILE
//START OF FILE: src/grail/helpers/tokenhistory.java
package grail.helpers;

import grail.interfaces.StoreToken;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"ClearableHistory"})
@StructurePattern(StructurePatternNames.LIST_PATTERN)
public interface TokenHistory {
	public void add(StoreToken element);
	public StoreToken get (int index); 
	public int size();
	public void clear();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/commandtoken.java
package grail.interfaces;

public interface CommandToken extends WordToken{

}
//END OF FILE
//START OF FILE: src/grail/interfaces/mutableiterator.java
package grail.interfaces;
import java.util.Iterator;

public interface MutableIterator extends Iterator<String> {

	public void setString(String input);
	public String getString();
	public void setCurrentPosition(int position);
	public int getCurrentPosition();

}
//END OF FILE
//START OF FILE: src/grail/interfaces/numbertoken.java
package grail.interfaces;

public interface NumberToken extends StoreToken {
	public int getValue();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/scannerbean.java
package grail.interfaces;

import grail.exceptions.ScanningException;
import grail.helpers.TokenHistory;
import util.models.PropertyListenerRegisterer;

public interface ScannerBean extends PropertyListenerRegisterer {
	public void setScannedString(String scannedString) throws ScanningException;
	public String getScannedString();
	public StoreToken[] getTokens();
	public String[] getErrors();
	public TokenHistory getTokenList();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/storetoken.java
package grail.interfaces;

public interface StoreToken {
	public void setInput(String storedString);
	public String getInput();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/undoablerunnable.java
package grail.interfaces;

public interface UndoableRunnable extends Runnable {
	public void undo();
	public void redo();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/wordtoken.java
package grail.interfaces;

public interface WordToken extends StoreToken {
	public String getValue();
}
//END OF FILE
//START OF FILE: src/grail/model/apropertylistenersupport.java
package grail.model;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

public class APropertyListenerSupport implements PropertyListenerSupport{
	private final int maxSize = 50;
	PropertyChangeListener[] contents = new PropertyChangeListener[maxSize];
	int size = 0;
	
	public int size() {
		return size;
	}

	private boolean isFull() {
		return size == maxSize;
	}
	
	public PropertyChangeListener elementAt(int index) {
		return contents[index];
	}

	
	public void addElement(PropertyChangeListener l) {
		if (isFull()) {
			//do nothing
		} else {
			contents[size] = l;
			size++;
		}
		
	}

	
	public void notifyAllListeners(PropertyChangeEvent event) {
		for (int index = 0; index < size(); index++) {
			elementAt(index).propertyChange(event);
	  }
	}

}
//END OF FILE
//START OF FILE: src/grail/model/propertylistenersupport.java
package grail.model;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

public interface PropertyListenerSupport {
	public int size();
	public PropertyChangeListener elementAt(int index);
	public void addElement(PropertyChangeListener l);
	public void notifyAllListeners(PropertyChangeEvent event);
}
//END OF FILE
//START OF FILE: src/grail/paint/aobservablepainter.java
package grail.paint;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.util.ArrayList;

import util.annotations.Tags;

@SuppressWarnings("serial")
@Tags({"ObservableBridgeScenePainter"})
public class AObservablePainter extends Component implements ObservablePainter {
	
	ArrayList<PaintListener> listenerList = new ArrayList<PaintListener>();
	
	public AObservablePainter() {
		setFocusable(true);
	}
	
	
    public void paint(Graphics g) {
		int index = 0;
    	while (index < listenerList.size()) {
			PaintListener currentListener = listenerList.get(index);
			currentListener.paint((Graphics2D)g);
			index++;
		}
    }
	
	public void repaint() {
		int index = 0;
		while (index < listenerList.size()) {
			PaintListener currentListener = listenerList.get(index);
			currentListener.paint((Graphics2D)this.getGraphics());
			index++;
		}	
		if (this.getParent() != null) {
			this.getParent().repaint();
		}
	
	}
	
	@Tags({"addPaintListener"})
	public void addPaintListener(PaintListener listener) {
		listenerList.add(listener);
	}



}
//END OF FILE
//START OF FILE: src/grail/paint/observablepainter.java
package grail.paint;

import java.awt.Graphics;

import util.annotations.Tags;

@Tags({"ObservableBridgeScenePainter"})
public interface ObservablePainter {
	public void addPaintListener(PaintListener listener);
	public void repaint();
	public void paint(Graphics g);
}
//END OF FILE
//START OF FILE: src/grail/paint/paintlistener.java
package grail.paint;

import java.awt.Graphics2D;

import util.annotations.Tags;

@Tags({"PaintListener"})
public interface PaintListener {
	public void paint(Graphics2D g);
}
//END OF FILE
//START OF FILE: src/grail/runnables/approachcommand.java
package grail.runnables;

import grail.avatar.Avatar;
import grail.scene.BridgeScene;
import util.annotations.Tags;

@Tags({"ApproachCommand"})
public class ApproachCommand implements Runnable{
	private BridgeScene scene;
	private Avatar thisAvatar;
		
	public ApproachCommand(BridgeScene scene, Avatar avatar) {
		this.scene = scene;
		this.thisAvatar = avatar;
	}

	public void run() {
		this.scene.approach(thisAvatar);
		
	}

}
//END OF FILE
//START OF FILE: src/grail/runnables/callcommand.java
package grail.runnables;

import grail.helpers.Table;
import util.annotations.Tags;

@Tags({"CallCommand"})
public class CallCommand implements Runnable{
	private String command;
	private Table<String,Runnable> commandList;
	
	public CallCommand(String commandName, Table<String,Runnable> list) {
		this.command = commandName;
		this.commandList = list;
	}

	public void run() {
		if (this.commandList.get(this.command) != null) {
			((Runnable) this.commandList.get(this.command)).run();
		} else {
			//do nothing
		}
	}

}
//END OF FILE
//START OF FILE: src/grail/runnables/commandlist.java
package grail.runnables;

import java.util.ArrayList;
import java.util.List;

import grail.interfaces.UndoableRunnable;
import util.annotations.Tags;

@Tags({"CommandList","Undoable"})
public class CommandList implements RunnableList {
	private List<Runnable> commandList;
	private boolean beenUndone;
	
	public CommandList() {
		commandList = new ArrayList<Runnable>();
		beenUndone = false;
	}

	public void run() {
		for(int i = 0; i < commandList.size(); i++) {
			commandList.get(i).run();
		}
		beenUndone = false;
	}
	
	@Tags({"add"})
	public void add(Runnable toAdd) {
		this.commandList.add(toAdd);
		
	}

	public void clear() {
		this.commandList.clear();
	}

	public void undo() {
		if (!beenUndone) {
			for (int i = 0; i < this.commandList.size(); i ++) {
				try {
					((UndoableRunnable) this.commandList.get(i)).undo();
				} catch (ClassCastException ce) {
					//do nothing
				}
			}	
		}
		this.beenUndone = true;
		
	}

	public void redo() {
		if (beenUndone) {
			for (int i = 0; i < this.commandList.size(); i ++) {
				try {
					((UndoableRunnable) this.commandList.get(i)).redo();
				} catch (ClassCastException ce) {
					//do nothing
				}
			}	
		}
		this.beenUndone = false;
	}

}
//END OF FILE
//START OF FILE: src/grail/runnables/defaultcommand.java
package grail.runnables;


public class DefaultCommand implements Runnable {

	public void run() {
		//do nothing

	}


}
//END OF FILE
//START OF FILE: src/grail/runnables/definecommand.java
package grail.runnables;

import grail.helpers.Table;
import util.annotations.Tags;

@Tags({"DefineCommand"})
public class DefineCommand implements Runnable{
	private String commandName;
	private Runnable commandToExecute;
	private Table<String,Runnable> commandList;
	
	public DefineCommand(String input, Runnable command, Table<String,Runnable> list) {
		this.commandName = input;
		this.commandToExecute = command;
		this.commandList = list;
	}

	public void run() {
		this.commandList.put(this.commandName, this.commandToExecute);
	}

}
//END OF FILE
//START OF FILE: src/grail/runnables/failcommand.java
package grail.runnables;

import grail.scene.BridgeScene;
import util.annotations.Tags;

@Tags({"FailCommand"})
public class FailCommand implements Runnable {
	private BridgeScene scene;
		
	public FailCommand(BridgeScene scene) {
		this.scene = scene;
	}

	public void run() {
		this.scene.failed();

	}

}
//END OF FILE
//START OF FILE: src/grail/runnables/movecommand.java
package grail.runnables;

import grail.avatar.Avatar;
import grail.interfaces.UndoableRunnable;
import util.annotations.Tags;

@Tags({"MoveCommand", "Undoable"})
public class MoveCommand implements UndoableRunnable{
	private Avatar avatar;
	private int x,y;
	private boolean beenUndone;
	
	public MoveCommand(Avatar avatar, int moveX, int moveY) {
		this.avatar = avatar;
		this.x = moveX;
		this.y = moveY;
		beenUndone = false;
	}

	public void run() {
		this.avatar.move(this.x, this.y);	
	}

	public void undo() {
		if (!this.beenUndone) {
			this.avatar.move(-this.x, -this.y);
			beenUndone = true;
		}
	}

	public void redo() {
		if (this.beenUndone) {
			this.avatar.move(this.x, this.y);
			beenUndone = false;
		}	
	}

}
//END OF FILE
//START OF FILE: src/grail/runnables/passcommand.java
package grail.runnables;

import grail.scene.BridgeScene;
import util.annotations.Tags;

@Tags({"PassCommand"})
public class PassCommand implements Runnable {
	private BridgeScene scene;
		
	public PassCommand(BridgeScene scene) {
		this.scene = scene;
	}

	public void run() {
		this.scene.passed();
	}

}
//END OF FILE
//START OF FILE: src/grail/runnables/proceedallcommand.java
package grail.runnables;

import grail.helpers.ClearanceManager;
import util.annotations.Tags;

@Tags({"ProceedAllCommand"})
public class ProceedAllCommand implements Runnable {
	private ClearanceManager manager;
	
	public ProceedAllCommand(ClearanceManager manager) {
		this.manager = manager;
	}

	public void run() {
		this.manager.proceedAll();
	}

}
//END OF FILE
//START OF FILE: src/grail/runnables/redocommand.java
package grail.runnables;

import grail.interfaces.UndoableRunnable;
import util.annotations.Tags;

@Tags({"RedoCommand"})
public class RedoCommand implements Runnable {
	private UndoableRunnable command;
	
	public RedoCommand(UndoableRunnable command) {
		this.command = command;
	}

	public void run() {
		this.command.redo();
	}


}
//END OF FILE
//START OF FILE: src/grail/runnables/repeatcommand.java
package grail.runnables;

import util.annotations.Tags;

@Tags({"RepeatCommand"})
public class RepeatCommand implements Runnable {
	private int timesToRun;
	private Runnable currentCommand;
	
	public RepeatCommand(int timeToRun, Runnable command ) {
		this.timesToRun = timeToRun;
		this.currentCommand = command;
	}

	public void run() {
		for (int i =0; i < timesToRun; i++) {
			this.currentCommand.run();
		}

	}

}
//END OF FILE
//START OF FILE: src/grail/runnables/rotateleftarmcommand.java
package grail.runnables;

import grail.avatar.Avatar;
import grail.interfaces.UndoableRunnable;
import util.annotations.Tags;

@Tags({"RotateLeftArmCommand","Undoable"})
public class RotateLeftArmCommand implements UndoableRunnable {
	private Avatar cAvatar;
	private int toRotate;
	private boolean beenUndone;
	
	public RotateLeftArmCommand(Avatar avatar, int rotate) {
		this.cAvatar = avatar;
		this.toRotate = rotate;
		beenUndone = false;
	}

	public void run() {
		this.cAvatar.getArms().getLeftLine().rotate(this.toRotate);
		beenUndone = false;
	}

	public void undo() {
		if (!beenUndone) {
			this.cAvatar.getArms().getLeftLine().rotate(-this.toRotate);
			beenUndone = true;
		}
		
	}

	public void redo() {
		if (beenUndone) {
			this.cAvatar.getArms().getLeftLine().rotate(this.toRotate);
			beenUndone = false;
		}		
	}

}
//END OF FILE
//START OF FILE: src/grail/runnables/rotaterightarmcommand.java
package grail.runnables;

import grail.avatar.Avatar;
import grail.interfaces.UndoableRunnable;
import util.annotations.Tags;

@Tags({"RotateRightArmCommand","Undoable"})
public class RotateRightArmCommand implements UndoableRunnable {
	private Avatar cAvatar;
	private int toRotate;
	private boolean beenUndone;
	
	public RotateRightArmCommand(Avatar avatar, int rotate) {
		this.cAvatar = avatar;
		this.toRotate = rotate;
		beenUndone = false;
	}

	public void run() {
		this.cAvatar.getArms().getRightLine().rotate(this.toRotate);
		beenUndone = false;
	}
	
	public void undo() {
		if (!beenUndone) {
			this.cAvatar.getArms().getRightLine().rotate(-this.toRotate);
			beenUndone = true;
		}		
	}

	public void redo() {
		if (beenUndone) {
			this.cAvatar.getArms().getRightLine().rotate(this.toRotate);
			beenUndone = false;
		}			
	}

}
//END OF FILE
//START OF FILE: src/grail/runnables/runnablelist.java
package grail.runnables;

import grail.interfaces.UndoableRunnable;

public interface RunnableList extends UndoableRunnable {
	public void add(Runnable toAdd);
	public void clear();
}
//END OF FILE
//START OF FILE: src/grail/runnables/saycommand.java
package grail.runnables;

import grail.scene.BridgeScene;
import util.annotations.Tags;

@Tags({"SayCommand"})
public class SayCommand implements Runnable{
	private BridgeScene scene;
	private String toSay;
	
	public SayCommand(BridgeScene scene, String input) {
		this.scene = scene;
		this.toSay = input;
	}
	
	public void run() {
		this.scene.say(toSay);
		
	}


}
//END OF FILE
//START OF FILE: src/grail/runnables/sleepcommand.java
package grail.runnables;

import util.annotations.Tags;
import util.misc.ThreadSupport;

@Tags({"SleepCommand"})
public class SleepCommand implements Runnable {
	long sleepTime;
	
	public SleepCommand(long sleepTime) {
		this.sleepTime = sleepTime;
	}

	public void run() {
		ThreadSupport.sleep(this.sleepTime);
	}

}
//END OF FILE
//START OF FILE: src/grail/runnables/threadcommand.java
package grail.runnables;

import grail.helpers.Table;
import util.annotations.Tags;

@Tags({"ThreadCommand"})
public class ThreadCommand implements Runnable{
	private String commandToExecute;
	private Table<String,Runnable> toList;
	
	public ThreadCommand(String command, Table<String,Runnable> list) {
		this.commandToExecute = command;
		this.toList = list;
	}

	public void run() {
		try {	
			Thread toRun = new Thread(((Runnable) this.toList.get(this.commandToExecute)));
			toRun.start();
		} catch (ClassCastException e) {
			//do nothing
		} catch (Exception e) {
			//do nothing
		}
	}

}
//END OF FILE
//START OF FILE: src/grail/runnables/undocommand.java
package grail.runnables;

import grail.interfaces.UndoableRunnable;
import util.annotations.Tags;

@Tags({"UndoCommand"})
public class UndoCommand implements Runnable{
	private UndoableRunnable command;
	
	public UndoCommand(UndoableRunnable command) {
		this.command = command;
	}

	public void run() {
		this.command.undo();
	}



}
//END OF FILE
//START OF FILE: src/grail/scene/basicbridgescene.java
package grail.scene;

import java.awt.Color;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

import grail.avatar.Avatar;
import grail.avatar.BasicAvatar;
import grail.draw.interfaces.BridgeMoat;
import grail.draw.interfaces.Platform;
import grail.draw.objects.BasicBridgeMoat;
import grail.draw.objects.PlatformOvalShape;
import grail.factories.SingletonsCreator;
import grail.helpers.BasicTable;
import grail.helpers.Table;
import grail.model.APropertyListenerSupport;
import grail.model.PropertyListenerSupport;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;
import util.misc.ThreadSupport;

@Tags({"BridgeScene"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"X", "Y", "Occupied", "KnightTurn", "KnightList","Arthur", "Lancelot", "Robin", "Galahad","Guard", "knightArea", "GuardArea", "Gorge"})
@EditablePropertyNames({"X", "Y"})
public class BasicBridgeScene implements BridgeScene {
	
	private Avatar arthur, lancelot, robin, galahad, guard;
	private int xSceneLocation, ySceneLocation;
	private Platform knightArea, guardArea;
	private BridgeMoat gorge;
	private boolean occupied, knightTurn;
	private Avatar knightAtSpot;
	private int questionNumber;
	private Table<String,Avatar> knightList;
	private PropertyListenerSupport propertyListenerList;

	
	public BasicBridgeScene() {
		this(new BasicAvatar("arthur.jpg"), new BasicAvatar("lancelot.jpg"), new BasicAvatar("robin.jpg"), new BasicAvatar("galahad.jpg"), new BasicAvatar("guard.jpg"));
	}
	
	public BasicBridgeScene(Avatar arthur, Avatar lancelot, Avatar robin, Avatar galahad, Avatar guard) {
		this.knightList = SingletonsCreator.avatarTableFactoryMethod();
		
		this.propertyListenerList = new APropertyListenerSupport();
		
		this.arthur = arthur;
		arthur.setBodyColor(Color.YELLOW);
		arthur.setTextColor(Color.YELLOW);
		this.knightList.put("arthur", this.arthur);
		
		this.lancelot = lancelot;
		lancelot.setBodyColor(Color.RED);
		lancelot.setTextColor(Color.RED);
		this.knightList.put("lancelot", this.lancelot);
		
		this.galahad = galahad;
		galahad.setBodyColor(Color.PINK);
		galahad.setTextColor(Color.PINK);
		this.knightList.put("galahad", this.galahad);
		
		this.robin = robin;
		robin.setBodyColor(Color.CYAN);
		robin.setTextColor(Color.CYAN);
		this.knightList.put("robin", this.robin);
		
		this.guard = guard;
		guard.setBodyColor(Color.DARK_GRAY);
		guard.setTextColor(Color.DARK_GRAY);
		this.knightList.put("guard", this.guard);
		
		this.xSceneLocation = 0;
		this.ySceneLocation = 0;
		
		this.knightArea = new PlatformOvalShape();
		this.guardArea = new PlatformOvalShape();
		this.gorge = new BasicBridgeMoat();
		
		setInitialScene(this.xSceneLocation, this.ySceneLocation);
		
		guard.setBasicText("I am the Guard!");
		galahad.setBasicText("I am Galahad!");
		robin.setBasicText("I am Robin!");
		lancelot.setBasicText("I am Lancelot!");
		arthur.setBasicText("Hello, I am Arthur!");
		
		
		this.occupied = false;
		this.knightTurn = false;
		
	}
	
	public Avatar getArthur() {
		return arthur;
	}


	public Avatar getLancelot() {
		return lancelot;
	}

	
	public Avatar getRobin() {
		return robin;
	}

	
	public Avatar getGalahad() {
		return galahad;
	}

	
	public Avatar getGuard() {
		return guard;
	}
	
	public Platform getKnightArea() {
		return this.knightArea;
	}
	
	public Platform getGuardArea(){
		return this.guardArea;
	}
	
	private void setInitialScene(int xPos, int yPos) {
		//positions and default locations
		final int firstLinePosXY = 50;
		final int secondLinePosY = 300;
		final int secondLinePosX = 250;
		final int platformPosY = 500;
		final int guardPlotX = 600;
		final int knightPlotX = 350;
		final int bridgeX = 800;
		
		final int firstLineY = firstLinePosXY + yPos;
		final int secondLineY = secondLinePosY + yPos;
		final int lancelotAndGalahadX = secondLinePosX + xPos;
		final int robinAndArthurX = firstLinePosXY + xPos;
		final int platformY = platformPosY + yPos;
		final int platformGuardX = guardPlotX + xPos;
		final int platformKnightX = knightPlotX + xPos;
		final int bridgeStartX = bridgeX + xPos;
		final int moatSizeX = 500;
		final int moatSizeY = 1000;
	
		arthur.setLocation(robinAndArthurX, firstLineY);
	
		lancelot.setLocation(lancelotAndGalahadX, firstLineY);
		
		robin.setLocation(robinAndArthurX, secondLineY);

		galahad.setLocation(lancelotAndGalahadX, secondLineY);

		this.knightArea.setLocation(platformKnightX, platformY);
		this.guardArea.setLocation(platformGuardX, platformY);

		guard.setLocation(this.guardArea.getAvatarX(guard), this.guardArea.getAvatarY(guard));

		
		this.gorge.setLocation(bridgeStartX, 0);
		this.gorge.setSize(moatSizeX, moatSizeY);
		
	}
	
	public void setX(int x) {
		this.xSceneLocation = x;
//		setGraphicScene(this.xSceneLocation, this.ySceneLocation);
	
	}
	
	
	public void setY(int y){
		this.ySceneLocation = y;
//		setGraphicScene(this.xSceneLocation, this.ySceneLocation);
	}
	
	public int getX(){return this.xSceneLocation;}
	
	public int getY(){return this.ySceneLocation;}
	
	@Tags({"scroll"})
	public void scroll(int x, int y) {
		this.arthur.move(x, y);
		this.galahad.move(x, y);
		this.robin.move(x, y);
		this.lancelot.move(x, y);
		this.guard.move(x, y);
		this.guardArea.move(x, y);
		this.knightArea.move(x, y);
		this.gorge.move(x, y);
		this.xSceneLocation = this.xSceneLocation + x;
		this.ySceneLocation = this.ySceneLocation + y;
		
	}

	public BridgeMoat getGorge() {
		return this.gorge;
	}

	public boolean preApproach() {
		return !this.occupied;
	}
	
	@Tags({"approach"})
	public void approach(Avatar avatarToApproach) {
		assert preApproach(): "The knight area is already occupied";
		if (!this.occupied) {
			avatarToApproach.setLocation(knightArea.getAvatarX(avatarToApproach), knightArea.getAvatarY(avatarToApproach));
			this.occupied = true;
			this.questionNumber = 0;
			this.knightAtSpot = avatarToApproach;
			this.knightTurn = false;
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "approach", false));
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "say", true));
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "failed", true));
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "passed", true));
		} else {
			//do nothing
		}
		
	}

	
	public boolean getOccupied() {
		return this.occupied;
	}

	
	public boolean preSay() {
	return (this.occupied);	
	}
	
	
	@Tags({"say"})
	public void say(String lineOfDialogue) {
		final int maxQuestionsAllowed = 100;
		assert preSay():"The Knight space is not occupied, Can't Say!";
		if (this.occupied && !this.knightTurn) {
			this.guard.setBasicText(lineOfDialogue);
			this.knightTurn = true;
			
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "approach", false));
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "say", true));
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "failed", true));
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "passed", false));
			
		} else if (this.occupied && this.knightTurn && this.questionNumber < maxQuestionsAllowed){
			this.knightAtSpot.setBasicText(lineOfDialogue);
			this.questionNumber++;
			this.knightTurn = false;
			
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "approach", false));
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "say", true));
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "failed", true));
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "passed", true));
		} else if (this.occupied && this.knightTurn) {
			this.knightTurn = false;
			failed();
		} else {
			//do nothing
		}
		
	}

	public boolean getKnightTurn() {
		return this.knightTurn;
	}

	public boolean prePassed() {
		return (this.occupied && !this.knightTurn);
	}
	
	@Tags({"passed"})
	public void passed() {
		assert prePassed():"It is not the guards turn.";
		if (this.occupied && !this.knightTurn) {
			marchAvatar();
			this.occupied = false;
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "approach", true));
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "say", false));
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "failed", false));
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "passed", false));
			
		} else {
			//do nothing
		}
		
	}

	public boolean preFailed() {
		return this.occupied;
	}
	
	@Tags({"failed"})
	public void failed() {
		assert preFailed():"The Knight space is not occupied!";
		if (this.occupied && !this.knightTurn) {
			this.knightAtSpot.setLocation(this.gorge.getFallZoneX(), this.gorge.getFallZoneY());
			fallAvatar();
			this.occupied = false;
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "approach", true));
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "say", false));
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "failed", false));
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "passed", false));
		} else if (this.occupied && knightTurn) {
			this.guard.setLocation(this.gorge.getFallZoneX(), this.gorge.getFallZoneY());
			fallAvatar();
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "approach", true));
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "say", false));
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "failed", false));
			this.propertyListenerList.notifyAllListeners(new PropertyChangeEvent(this, "this", "passed", false));
		} else {
			//do nothing
		}
		
	}

	private void marchAvatar() {
		final int distanceToMarch = 1000;
		final int moveIncrementX = 20;
		final int moveIncrementY = 0;
		final int rotationAmount = 8;
		final int sleepBetweenTimeMS = 200;
		int distanceMarched = 0;
		int position = 0;
		this.occupied = false;
		while (distanceMarched < distanceToMarch) {
			if (position == 0) {
				this.knightAtSpot.move(moveIncrementX, moveIncrementY);
				this.knightAtSpot.getLegs().rotate(-rotationAmount);
				distanceMarched = distanceMarched + moveIncrementX;
				ThreadSupport.sleep(sleepBetweenTimeMS);
				position = 1;
			} else {
				this.knightAtSpot.move(moveIncrementX, moveIncrementY);
				this.knightAtSpot.getLegs().rotate(rotationAmount);
				distanceMarched = distanceMarched + moveIncrementX;
				ThreadSupport.sleep(sleepBetweenTimeMS);
				position = 0;
			}
		}
		
	}
	
	private void fallAvatar() {
		final double shrinkFactor = .95;
		final int shrinkTimes = 20;
		final int waveRotate = 4;
		final int sleepTimeMS = 200;
		if (this.knightTurn) {
			int count = 0;
			while (count < shrinkTimes) {
				this.guard.scale(shrinkFactor);
				this.guard.getArms().rotate(waveRotate);
				this.guard.getLegs().rotate(waveRotate);
				count++;
				ThreadSupport.sleep(sleepTimeMS);
			}
		} else {
			int count = 0;
			while (count < shrinkTimes) {
				this.knightAtSpot.scale(shrinkFactor);
				this.knightAtSpot.getArms().rotate(waveRotate);
				this.knightAtSpot.getLegs().rotate(waveRotate);
				count++;
				ThreadSupport.sleep(sleepTimeMS);
			}
		} 
		
	}

	
	public Table<String,Avatar> getKnightList() {
		return this.knightList;
	}

	public void setOriginalPositions() {
		setInitialScene(this.xSceneLocation,this.ySceneLocation);
		
	}
	
	
	public static void registerListenerToAllSceneObjects(BridgeScene scene, PropertyChangeListener listener) {
		BasicAvatar.addBodyListener(scene.getArthur(), listener);
		BasicAvatar.addBodyListener(scene.getGalahad(), listener);
		BasicAvatar.addBodyListener(scene.getLancelot(), listener);
		BasicAvatar.addBodyListener(scene.getRobin(), listener);
		BasicAvatar.addBodyListener(scene.getGuard(), listener);
		scene.getKnightArea().addPropertyChangeListener(listener);
		PlatformOvalShape.addListenersToSubshapes(scene.getKnightArea(), listener);
		scene.getGuardArea().addPropertyChangeListener(listener);
		PlatformOvalShape.addListenersToSubshapes(scene.getGuardArea(), listener);
		scene.getGorge().addPropertyChangeListener(listener);
		BasicBridgeMoat.addListenerToSubShapes(scene.getGorge(), listener);
	}

	public void addPropertyChangeListener(PropertyChangeListener arg0) {
		this.propertyListenerList.addElement(arg0);
		
	}
}
//END OF FILE
//START OF FILE: src/grail/scene/bridgescene.java
package grail.scene;

import grail.avatar.Avatar;
import grail.draw.interfaces.BridgeMoat;
import grail.draw.interfaces.Platform;
import grail.helpers.Table;
import util.models.PropertyListenerRegisterer;

public interface BridgeScene extends PropertyListenerRegisterer{
	public Avatar getArthur();
	public Avatar getLancelot();
	public Avatar getRobin();
	public Avatar getGalahad();
	public Avatar getGuard();
	public BridgeMoat getGorge();
	public Platform getKnightArea();
	public Platform getGuardArea();
	public void scroll(int x , int y);
	public boolean getOccupied();
	public void approach(Avatar avatarToApproach);
	public void say(String lineOfDialogue);
	public void passed();
	public void failed();
	public boolean getKnightTurn();
	public Table<String,Avatar> getKnightList();
	public void setOriginalPositions();
	public boolean prePassed();
	public boolean preFailed();
	public boolean preSay();
	public boolean preApproach();
}
//END OF FILE
//START OF FILE: src/grail/tokens/basicstoretoken.java
package grail.tokens;

import grail.interfaces.StoreToken;
import util.annotations.Tags;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@Tags({"Basic"}) 
@StructurePattern(StructurePatternNames.BEAN_PATTERN) 
@PropertyNames({"Input"}) 
@EditablePropertyNames({"Input"})

public abstract class BasicStoreToken implements StoreToken {
	private String storedString = "";
	
	public BasicStoreToken(String input) {
		storedString = input;
	}
	
	public void setInput(String input) {
		storedString = input;
	}
	
	public String getInput() {
		return storedString;
	}
}
//END OF FILE
//START OF FILE: src/grail/tokens/endstoretoken.java
package grail.tokens;

import util.annotations.Tags;
import grail.interfaces.StoreToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@Tags({"End"}) 
@StructurePattern(StructurePatternNames.BEAN_PATTERN) 
@PropertyNames({"Input"}) 
@EditablePropertyNames({"Input"})

public class EndStoreToken extends BasicStoreToken implements StoreToken {

	public EndStoreToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokens/minusstoretoken.java
package grail.tokens;

import util.annotations.Tags;
import grail.interfaces.StoreToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@Tags({"Minus"}) 
@StructurePattern(StructurePatternNames.BEAN_PATTERN) 
@PropertyNames({"Input"}) 
@EditablePropertyNames({"Input"})

public class MinusStoreToken extends BasicStoreToken implements StoreToken {
		
	public MinusStoreToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokens/numberstoretoken.java
package grail.tokens;

import grail.interfaces.NumberToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.Tags;
import util.annotations.StructurePatternNames;

@Tags({"Number"}) 
@StructurePattern(StructurePatternNames.BEAN_PATTERN) 
@PropertyNames({"Input", "Value"}) 
@EditablePropertyNames({"Input"})

public class NumberStoreToken extends BasicStoreToken implements NumberToken {

	public NumberStoreToken(String input) {
		super(input);
	}

	public int getValue() {
		return Integer.parseInt(getInput());
	}

}
//END OF FILE
//START OF FILE: src/grail/tokens/plusstoretoken.java
package grail.tokens;

import grail.interfaces.StoreToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.Tags;
import util.annotations.StructurePatternNames;

@Tags({"Plus"}) 
@StructurePattern(StructurePatternNames.BEAN_PATTERN) 
@PropertyNames({"Input"}) 
@EditablePropertyNames({"Input"})

public class PlusStoreToken extends BasicStoreToken implements StoreToken{

	public PlusStoreToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokens/quotedstoretoken.java
package grail.tokens;

import util.annotations.Tags;
import grail.interfaces.StoreToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@Tags({"Quote"}) 
@StructurePattern(StructurePatternNames.BEAN_PATTERN) 
@PropertyNames({"Input"}) 
@EditablePropertyNames({"Input"})
public class QuotedStoreToken extends BasicStoreToken implements StoreToken{

	public QuotedStoreToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokens/startstoretoken.java
package grail.tokens;

import util.annotations.Tags;
import grail.interfaces.StoreToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@Tags({"Start"}) 
@StructurePattern(StructurePatternNames.BEAN_PATTERN) 
@PropertyNames({"Input"}) 
@EditablePropertyNames({"Input"})

public class StartStoreToken extends BasicStoreToken implements StoreToken {

	public StartStoreToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokens/wordstoretoken.java
package grail.tokens;

import grail.interfaces.WordToken;
import util.annotations.Tags;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@Tags({"Word"}) 
@StructurePattern(StructurePatternNames.BEAN_PATTERN) 
@PropertyNames({"Input","Value"}) 
@EditablePropertyNames({"Input"})

public class WordStoreToken extends BasicStoreToken implements WordToken{

	public WordStoreToken(String input) {
		super(input);
	}

	public String getValue() {
		return getInput().toLowerCase();
	}

	
}
//END OF FILE
//START OF FILE: src/grail/toolkit/advancedcommandviewer.java
package grail.toolkit;

import java.beans.PropertyChangeListener;
import javax.swing.JFrame;

public interface AdvancedCommandViewer extends CommandWidgets, PropertyChangeListener{
	public JFrame getFrame();
	public void placeFrameOnTop();
	
}
//END OF FILE
//START OF FILE: src/grail/toolkit/basiccommandcontroller.java
package grail.toolkit;

import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.beans.PropertyChangeEvent;

import javax.swing.JButton;
import javax.swing.JMenuItem;
import javax.swing.JTextField;

import grail.commander.CommandInterpreter;
import grail.factories.SingletonsCreator;
import grail.scene.BridgeScene;
import util.annotations.PropertyNames;
import util.annotations.Tags;

@Tags({"CommandInterpreterController"})
@PropertyNames({"MenuItem", "MenuItemTwo" , "Button", "ButtonTwo", "ButtonThree", "ButtonFour"}) 
public class BasicCommandController implements CommandController {
	CommandInterpreter currentInterpreter;
	CommandWidgets aWidget;
	JButton execute, arthurUp, arthurDown, arthurLeft, arthurRight, pass,say,fail,approach;
	JMenuItem sayHello, sayGoodbye;
	BridgeScene scene;
	
	
	public BasicCommandController(CommandInterpreter interpreter, CommandWidgets widget) {
		this.currentInterpreter = interpreter;
		this.aWidget = widget;
		this.execute = this.aWidget.getExecuteButton();
		this.arthurUp = this.aWidget.getArthurUp();
		this.arthurDown = this.aWidget.getArthurDown();
		this.arthurLeft = this.aWidget.getArthurLeft();
		this.arthurRight = this.aWidget.getArthurRight();
		this.sayHello = this.aWidget.getArthurHello();
		this.sayGoodbye = this.aWidget.getArthurGoodbye();
		this.pass = this.aWidget.getPassed();
		this.say = this.aWidget.getSay();
		this.fail = this.aWidget.getFailed();
		this.approach = this.aWidget.getApproach();
		this.aWidget.getCommandField().addKeyListener(this);
		this.execute.addActionListener(this);
		this.arthurUp.addActionListener(this);
		this.arthurDown.addActionListener(this);
		this.arthurLeft.addActionListener(this);
		this.arthurRight.addActionListener(this);
		this.sayHello.addActionListener(this);
		this.sayGoodbye.addActionListener(this);
		this.pass.addActionListener(this);
		this.say.addActionListener(this);
		this.fail.addActionListener(this);
		this.approach.addActionListener(this);
		this.say.setEnabled(false);
		this.pass.setEnabled(false);
		this.fail.setEnabled(false);
		this.approach.setEnabled(false);
		
		this.scene = SingletonsCreator.bridgeSceneFactoryMethod();
		this.scene.addPropertyChangeListener(this);
		this.say.setEnabled(this.scene.preSay());
		this.pass.setEnabled(this.scene.prePassed());
		this.fail.setEnabled(this.scene.preFailed());
		this.approach.setEnabled(this.scene.preApproach());
	}
	
	public BasicCommandController(CommandInterpreter interpreter) {
		this(interpreter, new ToolkitCommandViewer(interpreter));
	}
	
	public BasicCommandController(CommandWidgets viewer) {
		this (SingletonsCreator.commandInterpreterFactoryMethod(), viewer);
	}

	public void actionPerformed(ActionEvent e) {
		if (e.getSource() == this.execute) {
			this.currentInterpreter.setCommand(this.aWidget.getCommandField().getText());
		} else if (e.getSource() == this.arthurUp) {
			this.currentInterpreter.setCommand("move arthur + 0 + 100");
		} else if (e.getSource() == this.arthurDown) {
			this.currentInterpreter.setCommand("move arthur + 0 - 100");
		} else if (e.getSource() == this.arthurLeft) {
			this.currentInterpreter.setCommand("move arthur - 100 + 0 ");
		} else if (e.getSource() == this.arthurRight) {
			this.currentInterpreter.setCommand("move arthur + 100 + 0");
		} else if (e.getSource() == this.sayGoodbye) {
			this.currentInterpreter.setCommand("say \"Goodbye\"");
		} else if (e.getSource() == this.sayHello) {
			this.currentInterpreter.setCommand("say \"Hello\"");
		} else if (e.getSource() == this.say){
			this.scene.say("Hello!");
		} else if (e.getSource() == this.pass) {
			this.scene.passed();
		} else if (e.getSource() == this.fail) {
			this.scene.failed();
		} else if (e.getSource() == this.approach) {
			this.scene.approach(this.scene.getArthur());
		} else {
			//do nothing
		}
		
	}

	public JTextField getTextField(){return this.aWidget.getCommandField();}
	
	public JMenuItem getMenuItem() {return this.sayHello;}

	public JMenuItem getMenuItemTwo() {return this.sayGoodbye;}

	public JButton getButton() {return this.arthurRight;}

	public JButton getButtonTwo() {return this.arthurUp;}

	public JButton getButtonThree() {return this.arthurLeft;}

	public JButton getButtonFour() {return this.arthurDown;}
	
	public JButton getFail(){return this.fail;}
	
	public JButton getPass(){return this.pass;}
	
	public JButton getApproach(){return this.approach;}
	
	public JButton getSay(){return this.say;}

	public void propertyChange(PropertyChangeEvent evt) {
		if ("approach".equals(evt.getOldValue())) {
			this.approach.setEnabled((boolean)evt.getNewValue());
		} else if ("say".equals(evt.getOldValue())) {
			this.say.setEnabled((boolean)evt.getNewValue());
		} else if ("failed".equals(evt.getOldValue())) {
			this.fail.setEnabled((boolean)evt.getNewValue());
		} else if ("passed".equals(evt.getOldValue())) {
			this.pass.setEnabled((boolean)evt.getNewValue());
		} else {
			//do nothing
		}
		
	}

	public void keyTyped(KeyEvent e) {
		if (e.getKeyChar() == KeyEvent.VK_ENTER) {
			this.currentInterpreter.setCommand(this.aWidget.getCommandField().getText());
		}
	}

	public void keyPressed(KeyEvent e) {}

	public void keyReleased(KeyEvent e) {}
	
	

}
//END OF FILE
//START OF FILE: src/grail/toolkit/commandcontroller.java
package grail.toolkit;

import java.awt.event.ActionListener;
import java.awt.event.KeyListener;
import java.beans.PropertyChangeListener;
import javax.swing.JButton;
import javax.swing.JMenuItem;


public interface CommandController extends ActionListener, PropertyChangeListener, KeyListener{
	public JMenuItem getMenuItem();
	public JMenuItem getMenuItemTwo();
	public JButton getButton();
	public JButton getButtonTwo();
	public JButton getButtonThree();
	public JButton getButtonFour();
	public JButton getFail();
	public JButton getPass();
	public JButton getApproach();
	public JButton getSay();
}
//END OF FILE
//START OF FILE: src/grail/toolkit/commandwidgets.java
package grail.toolkit;

import javax.swing.JButton;
import javax.swing.JMenuItem;
import javax.swing.JTextArea;
import javax.swing.JTextField;

public interface CommandWidgets {
	public JTextField getCommandField();
	
	public JButton getExecuteButton();
	
	public JTextArea getErrorField();
	
	public JButton getArthurRight();
	
	public JButton getArthurLeft();
	
	public JButton getArthurUp();
	
	public JButton getArthurDown();
	
	public JMenuItem getArthurHello();
	
	public JMenuItem getArthurGoodbye();
	
	public JButton getSay();
	
	public JButton getApproach();
	
	public JButton getPassed();
	
	public JButton getFailed();
	
}
//END OF FILE
//START OF FILE: src/grail/toolkit/toolkitcommandviewer.java
package grail.toolkit;

import java.awt.event.KeyListener;
import java.beans.PropertyChangeEvent;
import javax.swing.JFrame;
import grail.commander.CommandInterpreter;
import grail.factories.SingletonsCreator;
import util.annotations.Tags;
import javax.swing.JTextField;
import javax.swing.ScrollPaneConstants;
import javax.swing.JLabel;
import javax.swing.JButton;
import javax.swing.JTextArea;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JScrollPane;
import javax.swing.JMenu;


@Tags({"ObservableCommandInterpreter"})
public class ToolkitCommandViewer implements AdvancedCommandViewer {
	private JFrame frame;
	private CommandInterpreter aModel;
	private JButton btnExecuteCommand, btnMoveArthurRight, btnMoveArthurLeft, btnMoveArthurUp, btnMoveArthurDown, pass, say, approach, fail;
	private JTextArea errorPane;
	private JTextField commandField;
	private JMenu mnSayCommands;
	private JMenuItem mntmArthurSaygoodbye, mntmArthurSayhello;
	private KeyListener listener;
	
	public ToolkitCommandViewer(CommandInterpreter model) {
		frame = new JFrame("Command Toolkit");
		this.aModel = model;
		this.aModel.addPropertyChangeListener(this);
		final int frameWidth = 500;
		final int frameHeight = 525;
		
		frame.setSize(frameWidth, frameHeight);
		frame.setResizable(false);
		frame.getContentPane().setLayout(null);
		frame.setFocusable(false);
		
		JMenuBar mnSay = new JMenuBar();
		frame.setJMenuBar(mnSay);
		
		mnSayCommands = new JMenu("Say Commands");
		mnSay.add(mnSayCommands);
		
		mntmArthurSayhello = new JMenuItem("Say \"Hello!\"");
		mnSayCommands.add(mntmArthurSayhello);
		
		mntmArthurSaygoodbye = new JMenuItem("Say \"Goodbye\"");
		mnSayCommands.add(mntmArthurSaygoodbye);
		
		final int cLabelUX = 30;
		final int cLabelUY = 32;
		final int cLabelLX = 73;
		final int cLabelLY = 16;
		JLabel lblCommand = new JLabel("Command:");
		lblCommand.setBounds(cLabelUX, cLabelUY, cLabelLX, cLabelLY);
		frame.getContentPane().add(lblCommand);
		
		final int eButtonUX = 169;
		final int eButtonUY = 60;
		final int eButtonLX = 155;
		final int eButtonLY = 29;
		btnExecuteCommand = new JButton("Execute Command");
		btnExecuteCommand.setBounds(eButtonUX, eButtonUY, eButtonLX, eButtonLY);
		frame.getContentPane().add(btnExecuteCommand);
		
		final int eLabelUX = 30;
		final int eLabelUY = 211;
		final int eLabelLX = 61;
		final int eLabelLY = 16;
		JLabel lblErrors = new JLabel("Errors:");
		lblErrors.setBounds(eLabelUX, eLabelUY, eLabelLX, eLabelLY);
		frame.getContentPane().add(lblErrors);
		
		final int tAreaUX = 40;
		final int tAreaUY = 239;
		final int tAreaLX = 435;
		final int tAreaLY = 110;
		errorPane = new JTextArea();
		errorPane.setLineWrap(true);
		errorPane.setWrapStyleWord(true);
		errorPane.setEditable(false);
		errorPane.setBounds(tAreaUX, tAreaUY, tAreaLX, tAreaLY);
		JScrollPane scrollPane = new JScrollPane(errorPane);
		scrollPane.setBounds(tAreaUX, tAreaUY, tAreaLX, tAreaLY);
		scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
		frame.getContentPane().add(scrollPane);
		
		final int pCommandUX = 30;
		final int pCommandUY = 110;
		final int pCommandLX = 155;
		final int pCommandLY = 16;
		JLabel lblPredefinedCommands = new JLabel("Predefined Commands:");
		lblPredefinedCommands.setBounds(pCommandUX, pCommandUY, pCommandLX, pCommandLY);
		frame.getContentPane().add(lblPredefinedCommands);
		
		final int bRightUX = 60;
		final int bRightUY = 138;
		final int bRightLX = 177;
		final int bRightLY = 29;
		btnMoveArthurRight = new JButton("Move Arthur +100 + 0");
		btnMoveArthurRight.setBounds(bRightUX, bRightUY, bRightLX, bRightLY);
		frame.getContentPane().add(btnMoveArthurRight);
		
		final int bLeftUX = 60;
		final int bLeftUY = 180;
		final int bLeftLX = 177;
		final int bLeftLY = 29;
		btnMoveArthurLeft = new JButton("Move Arthur - 100 + 0");
		btnMoveArthurLeft.setBounds(bLeftUX, bLeftUY, bLeftLX, bLeftLY);
		frame.getContentPane().add(btnMoveArthurLeft);
		
		
		final int bUpUX = 272;
		final int bUpUY = 138;
		final int bUpLX = 177;
		final int bUpLY = 29;
		btnMoveArthurUp = new JButton("Move Arthur + 0 +100");
		btnMoveArthurUp.setBounds(bUpUX, bUpUY, bUpLX , bUpLY);
		frame.getContentPane().add(btnMoveArthurUp);
		
		final int bDownUX = 272;
		final int bDownUY = 180;
		final int bDownLX = 177;
		final int bDownLY = 29;
		btnMoveArthurDown = new JButton("Move Arthur + 0 - 100");
		btnMoveArthurDown.setBounds(bDownUX, bDownUY, bDownLX, bDownLY);
		frame.getContentPane().add(btnMoveArthurDown);
		
		final int cFieldUX = 115;
		final int cFieldUY = 26;
		final int cFieldLX = 360;
		final int cFieldLY = 28;
		commandField = new JTextField();
		commandField.addKeyListener(this.listener);
		commandField.setBounds(cFieldUX, cFieldUY, cFieldLX, cFieldLY);
		frame.getContentPane().add(commandField);
		final int columnNumber = 10;
		commandField.setColumns(columnNumber);
		
		final int aButtonUX = 60;
		final int aButtonUY = 405;
		final int aButtonLX = 177;
		final int aButtonLY = 29;
		approach = new JButton("Approach Arthur");
		approach.setBounds(aButtonUX, aButtonUY, aButtonLX, aButtonLY);
		frame.getContentPane().add(approach);
		
		final int sFieldUX = 30;
		final int sFieldUY = 377;
		final int sFieldLX = 108;
		final int sFieldLY = 16;
		JLabel lblSceneMethods = new JLabel("Scene Methods:");
		lblSceneMethods.setBounds(sFieldUX, sFieldUY, sFieldLX, sFieldLY);
		frame.getContentPane().add(lblSceneMethods);
		
		final int pButtonUX = 134;
		final int pButtonUY = 440;
		final int pButtonLX = 117;
		final int pButtonLY = 29;
		pass = new JButton("Pass");
		pass.setBounds(pButtonUX, pButtonUY, pButtonLX, pButtonLY);
		frame.getContentPane().add(pass);
		
		final int fButtonUX = 252;
		final int fButtonUY = 440;
		final int fButtonLX = 117;
		final int fButtonLY = 29;
		fail = new JButton("Failed");
		fail.setBounds(fButtonUX, fButtonUY, fButtonLX, fButtonLY);
		frame.getContentPane().add(fail);
		
		final int sButtonUX = 272;
		final int sButtonUY = 405;
		final int sButtonLX = 177;
		final int sButtonLY = 29;
		say = new JButton("Say \"Hello\"");
		say.setBounds(sButtonUX, sButtonUY, sButtonLX, sButtonLY);
		frame.getContentPane().add(say);
		
		frame.setVisible(true);
	}
	
	public ToolkitCommandViewer() {
		this (SingletonsCreator.commandInterpreterFactoryMethod());
	}
	

	public void propertyChange(PropertyChangeEvent evt) {
		this.commandField.setText("");
		this.errorPane.setText(this.aModel.getErrors());
	}
	
	public JButton getExecuteButton() {return this.btnExecuteCommand;}
	
	public JButton getArthurRight() { return this.btnMoveArthurRight;}
	
	public JButton getArthurLeft() {return this.btnMoveArthurLeft;}
	
	public JButton getArthurUp() {return this.btnMoveArthurUp;}
	
	public JButton getArthurDown() {return this.btnMoveArthurDown;}
	
	public JTextField getCommandField() {return this.commandField;}
	
	public JMenuItem getArthurHello() {return this.mntmArthurSayhello;}
	
	public JMenuItem getArthurGoodbye(){return this.mntmArthurSaygoodbye;}

	public void placeFrameOnTop() {this.frame.toFront();}
	
	public JFrame getFrame() {return this.frame;}

	public JTextArea getErrorField() {return this.errorPane;}

	public JButton getSay() {return this.say;}

	public JButton getApproach() {return this.approach;}

	public JButton getPassed() {return this.pass;}

	public JButton getFailed() {return this.fail;}
}
//END OF FILE
//START OF FILE: src/grail/view/abackgroundview.java
package grail.view;

import java.awt.Graphics2D;
import java.beans.PropertyChangeEvent;
import grail.draw.interfaces.Rectangle;
import grail.paint.ObservablePainter;

public class ABackgroundView implements BackgroundView {
	ObservablePainter aModel;
	Rectangle aBackground;
	
	public ABackgroundView(Rectangle background, ObservablePainter model) {
		this.aModel = model;
		this.aBackground = background;
		this.aBackground.addPropertyChangeListener(this);
	}

	
	public void paint(Graphics2D g) {
		g.setPaint(this.aBackground.getColor());
		g.setBackground(this.aBackground.getColor());
		draw(g,this.aBackground);
	}
	
	public void draw(Graphics2D g, Rectangle background) {
		g.fillRect(background.getX(), background.getY(), background.getWidth(), background.getHeight());
	}


	public void propertyChange(PropertyChangeEvent evt) {
		this.aModel.repaint();
	}

}
//END OF FILE
//START OF FILE: src/grail/view/agorgeview.java
package grail.view;

import java.awt.Color;
import java.awt.Graphics2D;
import java.beans.PropertyChangeEvent;
import grail.draw.interfaces.BridgeMoat;
import grail.draw.interfaces.RotatingShape;
import grail.draw.objects.BasicBridgeMoat;
import grail.paint.ObservablePainter;

public class AGorgeView implements GorgeView{
	ObservablePainter aModel;
	BridgeMoat moat;
	
	public AGorgeView(BridgeMoat moat, ObservablePainter model) {
		this.aModel = model;
		this.moat = moat;
		this.moat.addPropertyChangeListener(this);
		BasicBridgeMoat.addListenerToSubShapes(this.moat, this);
	}

	@Override
	public void paint(Graphics2D g) {
		g.setPaint(Color.BLACK);
		draw(g, this.moat.getBridgeTop());
		draw(g, this.moat.getBridgeBottom());
		draw(g, this.moat.getMoatLeft());
		draw(g, this.moat.getMoatRight());
		draw(g, this.moat.getPlankOne());
		draw(g, this.moat.getPlankTwo());
		draw(g, this.moat.getPlankThree());
		draw(g, this.moat.getPlankFour());
		draw(g, this.moat.getPlankFive());
		draw(g, this.moat.getPlankSix());
		
	}

	@Override
	public void propertyChange(PropertyChangeEvent evt) {
		this.aModel.repaint();
		
	}
	
    public void draw(Graphics2D g, RotatingShape line) {
    	g.drawLine(line.getX(), line.getY(), line.getX() + line.getWidth(), line.getY() + line.getHeight());
    }

}
//END OF FILE
//START OF FILE: src/grail/view/aplatformview.java
package grail.view;

import java.awt.Graphics2D;
import java.beans.PropertyChangeEvent;
import grail.draw.interfaces.Platform;
import grail.draw.objects.PlatformOvalShape;
import grail.paint.ObservablePainter;

public class APlatformView implements PlatformView{
	Platform object;
	ObservablePainter aModel;
	
	public APlatformView(Platform object , ObservablePainter model) {
		this.aModel = model;
		this.object = object;
		this.object.addPropertyChangeListener(this);
		PlatformOvalShape.addListenersToSubshapes(this.object, this);
		
	}



	public void propertyChange(PropertyChangeEvent evt) {
		this.aModel.repaint();	
	}



	@Override
	public void paint(Graphics2D g) {
		g.setPaint(this.object.getShadow().getColor());
		g.fillOval(this.object.getShadow().getX(), this.object.getShadow().getY(), this.object.getShadow().getWidth(), this.object.getShadow().getHeight());
		g.setPaint(this.object.getPlatform().getColor());
		g.fillOval(this.object.getPlatform().getX(), this.object.getPlatform().getY(), this.object.getPlatform().getWidth(), this.object.getPlatform().getHeight());
	}
	
}
//END OF FILE
//START OF FILE: src/grail/view/anavatarview.java
package grail.view;

import java.awt.Component;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Toolkit;
import java.beans.PropertyChangeEvent;
import grail.avatar.Avatar;
import grail.avatar.BasicAvatar;
import grail.paint.ObservablePainter;
import grail.draw.interfaces.ImageShape;
import grail.draw.interfaces.RotatingShape;
import grail.draw.interfaces.StringShape;
import util.annotations.Tags;

@Tags({"ObservingBridgeScenePainter"})
public class AnAvatarView implements AvatarView{
	Avatar currentAvatar;
	ObservablePainter aModel;
	
	public AnAvatarView(Avatar avatar, ObservablePainter model) {
		currentAvatar = avatar;
		this.aModel = model;
		BasicAvatar.addBodyListener(currentAvatar, this);
	}

	public void propertyChange(PropertyChangeEvent evt) {
		aModel.repaint();
	}

    public void paint(Graphics2D g) {
        Graphics2D g2 = (Graphics2D) g;
        g.setColor(this.currentAvatar.getBodyColor());  
        draw(g2, this.currentAvatar);
    }
    
    public void draw(Graphics2D g, Avatar avatar) {
    	draw(g, avatar.getBody());
    	draw(g, avatar.getHead());
    	draw(g, avatar.getText());
    	draw(g, avatar.getLegs().getLeftLine());
    	draw(g, avatar.getLegs().getRightLine());
    	draw(g, avatar.getArms().getRightLine());
    	draw(g, avatar.getArms().getLeftLine());
        
        
    }

    public void draw(Graphics2D g, StringShape aLabel) {
        String s = aLabel.getText();
        g.drawString(s, aLabel.getX(), aLabel.getY()); 
    }
    
    public  void draw(Graphics2D g, ImageShape anImage) {
        Image img = Toolkit.getDefaultToolkit().getImage(anImage.getImageFileName());
        g.drawImage(img, anImage.getX(), anImage.getY(), ((Component)this.aModel));     
    }
    
    public void draw(Graphics2D g, RotatingShape line) {
    	g.drawLine(line.getX(), line.getY(), line.getX() + line.getWidth(), line.getY() + line.getHeight());
    }


}
//END OF FILE
//START OF FILE: src/grail/view/avatarview.java
package grail.view;
import java.awt.Graphics2D;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

import grail.avatar.Avatar;
import grail.draw.interfaces.ImageShape;
import grail.draw.interfaces.RotatingShape;
import grail.draw.interfaces.StringShape;
import grail.paint.PaintListener;

public interface AvatarView extends PaintListener, PropertyChangeListener {

	public void propertyChange(PropertyChangeEvent evt); 

    public void paint(Graphics2D g); 
    
    public void draw(Graphics2D g, Avatar avatar);

    public void draw(Graphics2D g, StringShape aLabel);
    
    public  void draw(Graphics2D g, ImageShape anImage);
    
    public void draw(Graphics2D g, RotatingShape line);
}
//END OF FILE
//START OF FILE: src/grail/view/backgroundview.java
package grail.view;

import java.beans.PropertyChangeListener;

import grail.paint.PaintListener;

public interface BackgroundView extends PaintListener, PropertyChangeListener{
	
}
//END OF FILE
//START OF FILE: src/grail/view/basicconsole.java
package grail.view;

import java.beans.PropertyChangeEvent;

import grail.avatar.BasicAvatar;
import grail.draw.objects.BasicBridgeMoat;
import grail.draw.objects.PlatformOvalShape;
import grail.scene.BridgeScene;
import util.annotations.Tags;

@Tags({"ConsoleSceneView"})
public class BasicConsole implements Console{
	BridgeScene scene;
	
	public BasicConsole(BridgeScene listenerScene) {
		setScene(listenerScene);
	}

	public void propertyChange(PropertyChangeEvent evt) {
		if (evt.getSource() == this.scene) {
		System.out.println("Precondition in Scene was changed. Method Name: " + evt.getOldValue() + " PreCondition is now: " + evt.getNewValue());	
		} else {
		System.out.println("Source: " + evt.getSource() + " Property To Change: " + evt.getPropertyName() + " Old Value: " + evt.getOldValue() + " New Value: " + evt.getNewValue());
		}
	}

	
	public BridgeScene getScene() {
		return this.scene;
	}

	
	public void setScene(BridgeScene toListen) {
		this.scene = toListen;
	
		BasicAvatar.addBodyListener(this.scene.getArthur(),this);
		
		BasicAvatar.addBodyListener(this.scene.getGalahad(),this);
		
		BasicAvatar.addBodyListener(this.scene.getGuard(), this);
		
		BasicAvatar.addBodyListener(this.scene.getLancelot(), this);
		
		BasicAvatar.addBodyListener(this.scene.getRobin(), this);
		
		this.scene.getGorge().addPropertyChangeListener(this);
		BasicBridgeMoat.addListenerToSubShapes(this.scene.getGorge(), this);
		
		
		this.scene.getGuardArea().addPropertyChangeListener(this);
		PlatformOvalShape.addListenersToSubshapes(this.scene.getGuardArea(), this);
		
		this.scene.getKnightArea().addPropertyChangeListener(this);
		PlatformOvalShape.addListenersToSubshapes(this.scene.getKnightArea(), this);
		
		this.scene.addPropertyChangeListener(this);
		
	}


}
//END OF FILE
//START OF FILE: src/grail/view/basicprogressview.java
package grail.view;

import java.beans.PropertyChangeEvent;
import javax.swing.JFrame;
import javax.swing.JProgressBar;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.Tags;

import javax.swing.JLabel;

@Tags({"ProgressBarCreator"})
@PropertyNames({"ProgressBar"}) 
@EditablePropertyNames({"ProgressBarMax"})
public class BasicProgressView implements ProgressView{
	private JProgressBar progressBar;
	private JFrame frame;
	private int progressBarMax;
	
	public BasicProgressView() {
		this.frame = new JFrame("Progress Bar");
		final int progressBarMaxDefault = 100;
		final int frameWidth = 400;
		final int frameHeight = 100;
		final int frameXLocation = 1100;
		final int frameYLocation = 0;
		
		frame.setSize(frameWidth, frameHeight);
		frame.setLocation(frameXLocation ,frameYLocation);
		frame.setResizable(false);
		frame.getContentPane().setLayout(null);
		
		final int upperX = 6;
		final int upperY = 47;
		final int lowerX = 388;
		final int lowerY = 20;
		this.progressBarMax = progressBarMaxDefault;
		progressBar = new JProgressBar();
		this.progressBar.setMaximum(progressBarMaxDefault);
		progressBar.setBounds(upperX, upperY, lowerX, lowerY);
		frame.getContentPane().add(progressBar);
		
		final int upperYTwo = 18;
		final int lowerXTwo = 61;
		final int lowerYTwo = 16;
		JLabel lblProgress = new JLabel("Progress:");
		lblProgress.setBounds(upperX, upperYTwo, lowerXTwo, lowerYTwo);
		frame.getContentPane().add(lblProgress);
		
		frame.setVisible(true);
		
	}

	public void propertyChange(PropertyChangeEvent evt) {
		if ("Progress".equals(evt.getPropertyName())) {
			int currentProgress = (int) evt.getNewValue();
			this.progressBar.setValue(currentProgress);
		}
		frame.toFront();
	}
	
	public void setProgressBarMax(int max) {
		this.progressBarMax = max;
		this.progressBar.setMaximum(max);
	}
	
	public int getProgressBarMax() {
		return this.progressBarMax;
	}

	public JProgressBar getProgressBar() {
		return this.progressBar;
	}

	public void bringToFront() {
		this.frame.toFront();
	}

	public void setLocation(int x, int y) {
		this.frame.setLocation(x, y);
	}
}
//END OF FILE
//START OF FILE: src/grail/view/console.java
package grail.view;

import java.beans.PropertyChangeListener;

import grail.scene.BridgeScene;
import util.annotations.Tags;

@Tags({"ConsoleSceneView"})
public interface Console extends PropertyChangeListener {
	public BridgeScene getScene();
	public void setScene(BridgeScene toListen);
	
}
//END OF FILE
//START OF FILE: src/grail/view/gorgeview.java
package grail.view;

import java.beans.PropertyChangeListener;

import grail.paint.PaintListener;

public interface GorgeView extends PaintListener, PropertyChangeListener {

}
//END OF FILE
//START OF FILE: src/grail/view/platformview.java
package grail.view;

import java.beans.PropertyChangeListener;

import grail.paint.PaintListener;

public interface PlatformView extends PaintListener, PropertyChangeListener {

}
//END OF FILE
//START OF FILE: src/grail/view/progressview.java
package grail.view;

import java.beans.PropertyChangeListener;

import javax.swing.JProgressBar;

public interface ProgressView extends PropertyChangeListener{
	public void setProgressBarMax(int max);
	public JProgressBar getProgressBar();
	public int getProgressBarMax();
	public void bringToFront();
	public void setLocation(int x, int y);
}
//END OF FILE
//START OF FILE: src/main/assignment12.java
package main;

import grail.demo.Assignment12Demo;
import grail.demo.TwelveDemo;
import grail.view.BasicProgressView;
import grail.view.ProgressView;


public class Assignment12 {
	
	public static void main(String[] args) {
		final int progressViewX = 1200;
		final int progressViewY = 825;
		TwelveDemo assignmentDemo = new Assignment12Demo();		
		ProgressView progress = new BasicProgressView();
		assignmentDemo.addPropertyChangeListener(progress);
		progress.setLocation(progressViewX, progressViewY);
		progress.bringToFront();
		
		assignmentDemo.run();
	}
	
}
//END OF FILE
